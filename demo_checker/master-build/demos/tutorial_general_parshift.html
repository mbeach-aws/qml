
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta content="Reconstruct quantum functions and compute their derivatives." property="og:description" />
<meta content="https://pennylane.ai/qml/_images/thumbnail_genpar.png" property="og:image" />

  <link rel="icon" type="image/x-icon" href="../_static/favicon.ico">
  <link rel="shortcut icon" type="image/x-icon" href="../_static/favicon.ico">
  


  <meta property="og:title" content="Generalized parameter-shift rules &#8212; PennyLane">
  <meta property="og:url" content="https://pennylane.ai/qml/demos/tutorial_general_parshift.html">
  <meta property="og:type" content="website">
  <meta name="twitter:card" content="summary_large_image">

  
  
  <meta content="Reconstruct quantum functions and compute their derivatives." property="og:description" />
  

  <!-- Google Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto&display=swap">
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.8.2/css/all.css">
  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
  <!-- Material Design Bootstrap -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.5.14/css/mdb.min.css">
  <!-- NanoScroller -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/css/nanoscroller.min.css">
  <!-- Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/tomorrow-night.min.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       "HTML-CSS": { scale: 90, linebreaks: { automatic: true } },
       TeX: {
         Macros: {
           pr : ['|\#1\\rangle\\langle\#1|',1],
           ket: ['\\left| \#1\\right\\rangle',1],
           bra: ['\\left\\langle \#1\\right|',1],
           xket: ['\\left| \#1\\right\\rangle_x',1],
           xbra: ['\\left\\langle \#1\\right|_x',1],
           braket: ['\\langle \#1 \\rangle',1],
           braketD: ['\\langle \#1 \\mid \#2 \\rangle',2],
           braketT: ['\\langle \#1 \\mid \#2 \\mid \#3 \\rangle',3],
           ketbra: ['| #1 \\rangle \\langle #2 |',2],
           hc: ['\\text{h.c.}',0],
           cc: ['\\text{c.c.}',0],
           h: ['\\hat',0],
           nn: ['\\nonumber',0],
           di: ['\\frac{d}{d \#1}',1],
           uu: ['\\mathcal{U}',0],
           inn: ['\\text{in}',0],
           out: ['\\text{out}',0],
           vac: ['\\text{vac}',0],
           I: ['\\hat{\\mathbf{1}}',0],
           x: ['\\hat{x}',0],
           p: ['\\hat{p}',0],
           a: ['\\hat{a}',0],
           ad: ['\\hat{a}^\\dagger',0],
           n: ['\\hat{n}',0],
           nbar: ['\\overline{n}',0],
           sech: ['\\mathrm{sech~}',0],
           tanh: ['\\mathrm{tanh~}',0],
           re: ['\\text{Re}',0],
           im: ['\\text{Im}',0],
           tr: ['\\mathrm{Tr} #1',1],
           sign: ['\\text{sign}',0],
           overlr: ['\\overset\\leftrightarrow{\#1}',1],
           overl: ['\\overset\leftarrow{\#1}',1],
           overr: ['\\overset\rightarrow{\#1}',1],
           avg: ['\\left< \#1 \\right>',1],
           slashed: ['\\cancel{\#1}',1],
           bold: ['\\boldsymbol{\#1}',1],
           d: ['\\mathrm d',0],
           expect: ["\\langle #1 \\rangle",1],
           pde: ["\\frac{\\partial}{\\partial \#1}",1],
           R: ["\\mathbb{R}",0],
           C: ["\\mathbb{C}",0],
           Ad: ["\\text{Ad}",0],
           Var: ["\\text{Var}",0],
           bx: ["\\mathbf{x}", 0],
           bm: ["\\boldsymbol{\#1}",1],
           haf: ["\\mathrm{haf}",0],
           lhaf: ["\\mathrm{lhaf}",0]
         }
       }
     });
     </script>

  <!-- Google Analytics -->
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130507810-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-130507810-1');
      </script>
  
    <title>Generalized parameter-shift rules &#8212; PennyLane  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/xanadu.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sg_gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/light-slider.css" />
    <link rel="stylesheet" type="text/css" href="../_static/css/hubs.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="canonical" href="https://pennylane.ai/qml/demos/tutorial_general_parshift.html" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Doubly stochastic gradient descent" href="tutorial_doubly_stochastic.html" />
    <link rel="prev" title="Optimization using SPSA" href="tutorial_spsa.html" /> 
  </head><body><nav class="navbar navbar-expand-lg navbar-light white sticky-top">

<!-- Logo and Title -->









  



  <a class="navbar-brand nav-link" href="https://pennylane.ai">
    
  <img class="pr-1" src=" ../_static/logo.png" width="28px"></img>
  
    <img id="navbar-wordmark" src="../_static/pennylane.svg"></img>
  
  </a>


  <!-- [Mobile] Collapse Button -->
  <div class="row right">
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#basicExampleNav"
      aria-controls="basicExampleNav" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
  </div>

  <!-- [Mobile] Collapsible Content -->
  <div class="collapse navbar-collapse" id="basicExampleNav">

    <!-- Links on the Left -->
    <ul class="navbar-nav mr-auto">
      
        
          
            <li class="nav-item active">
              <a class="nav-link" href="https://pennylane.ai/qml/">
                
  
    Learn
  

              </a>
              <span class="sr-only">(current)</span>
            </li>
          

        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/qml/demonstrations.html">
                
  
    Demos
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/install.html">
                
  
    Install
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/plugins.html">
                
  
    Plugins
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://docs.pennylane.ai">
                
  
    Documentation
  

            </a>
          </li>
        
      
        
          <li class="nav-item">
            <a class="nav-link" href="https://pennylane.ai/blog/">
                
  
    Blog
  

            </a>
          </li>
        
      
    </ul>

    <!-- Links on the Right -->
    <ul class="navbar-nav ml-auto nav-flex-icons">
      
        <li class="nav-item">
          <a class="nav-link" href="https://pennylane.ai/faq.html">
            <i class="fas fa-question pr-1"></i> FAQ
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://discuss.pennylane.ai/">
            <i class="fab fa-discourse pr-1"></i> Support
          </a>
        </li>
      
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/PennyLaneAI/pennylane">
            <i class="fab fa-github pr-1"></i> GitHub
          </a>
        </li>
      

    </ul>
  </div>

</nav>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="tutorial_doubly_stochastic.html" title="Doubly stochastic gradient descent"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="tutorial_spsa.html" title="Optimization using SPSA"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" accesskey="U">Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Generalized parameter-shift rules</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">
        <div id="content">
          <div id="right-column">
            
            

            <div class="document clearer body">
              
    <div class="sphx-glr-download-link-note admonition note">
<p class="admonition-title">Note</p>
<p>Click <a class="reference internal" href="#sphx-glr-download-demos-tutorial-general-parshift-py"><span class="std std-ref">here</span></a>
to download the full example code</p>
</div>
<div class="sphx-glr-example-title section" id="generalized-parameter-shift-rules">
<span id="general-parshift"></span><span id="sphx-glr-demos-tutorial-general-parshift-py"></span><h1>Generalized parameter-shift rules<a class="headerlink" href="#generalized-parameter-shift-rules" title="Permalink to this headline">¶</a></h1>
<p><script type="text/javascript">
    var related_tutorials = ["tutorial_expressivity_fourier_series.html", "tutorial_rotoselect.html", "tutorial_quantum_analytic_descent.html"];
    var related_tutorials_titles = ['Quantum models as Fourier series', 'Quantum circuit structure learning', 'Quantum analytic descent'];
</script></p>
<p><em>Author: David Wierichs (Xanadu Resident) — Posted: 23 August 2021. Last updated: 27 August 2021</em></p>
<p>In this demo we will look at univariate quantum functions, i.e., those that
depend on a single parameter. We will investigate the form such functions usually take
and demonstrate how we can <em>reconstruct</em> them as classical functions, capturing the full
dependence on the input parameter.
Once we have this reconstruction, we use it to compute analytically exact derivatives
of the quantum function. We implement this in two ways:
first, by using autodifferentiation on the classical function that is produced by the
reconstruction, which is flexible with respect to the degree of the derivative.
Second, by computing the derivative manually, resulting in generalized parameter-shift
rules for quantum functions that is more efficient (regarding classical cost) than the
autodifferentiation approach, but requires manual computations if we want to access
higher-order derivatives.
All we will need for the demo is the insight that these functions are Fourier series in their
variable, and the reconstruction itself is a
<a class="reference external" href="https://en.wikipedia.org/wiki/Trigonometric_interpolation">trigonometric interpolation</a>.</p>
<p>A full description of the reconstruction, the technical derivation of the parameter-shift
rules, and considerations for multivariate functions can be found in the paper
<a class="reference external" href="https://arxiv.org/abs/2107.12390">General parameter-shift rules for quantum gradients</a>
<a class="footnote-reference brackets" href="#genpar" id="id1">1</a>.
The core idea to consider these quantum functions as Fourier series was first presented in
the preprint
<a class="reference external" href="https://arxiv.org/abs/1812.06323">Calculus on parameterized quantum circuits</a> <a class="footnote-reference brackets" href="#calcpqc" id="id2">2</a>.
We will follow <a class="footnote-reference brackets" href="#genpar" id="id3">1</a>, but there also are two preprints discussing general parameter-shift
rules: an algebraic approach in
<a class="reference external" href="https://arxiv.org/abs/2107.08131">Analytic gradients in variational quantum algorithms: Algebraic extensions of the parameter-shift rule to general unitary transformations</a> <a class="footnote-reference brackets" href="#algeshift" id="id4">4</a>
and one focusing on special gates and spectral decompositions, namely
<a class="reference external" href="https://arxiv.org/abs/2108.01218">Generalized quantum circuit differentiation rules</a>
<a class="footnote-reference brackets" href="#gendiffrules" id="id5">5</a>.</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<div class="figure align-center" id="id10">
<a class="reference external image-reference" href="javascript:void(0)"><img alt="../_images/thumbnail_genpar.png" src="../_images/thumbnail_genpar.png" style="width: 50%;" /></a>
<p class="caption"><span class="caption-text">Function reconstruction and differentiation via parameter shifts.</span><a class="headerlink" href="#id10" title="Permalink to this image">¶</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Before going through this tutorial, we recommend that readers refer to the
<a class="reference internal" href="tutorial_expressivity_fourier_series.html"><span class="doc">Fourier series expressiveness tutorial</span></a>.
Additionally, having a basic understanding of the
<a class="reference internal" href="../glossary/parameter_shift.html"><span class="doc">parameter-shift rule</span></a> might make this tutorial easier
to dive into.</p>
</div>
<div class="section" id="cost-functions-arising-from-quantum-gates">
<h2>Cost functions arising from quantum gates<a class="headerlink" href="#cost-functions-arising-from-quantum-gates" title="Permalink to this headline">¶</a></h2>
<p>We start our investigation by considering a cost function that arises from measuring the expectation
value of an observable in a quantum state, created with a parametrized quantum operation
that depends on a single variational parameter <span class="math notranslate nohighlight">\(x\)</span>.
That is, the state may be prepared by any circuit, but we will only allow a single parameter
in a single operation to enter the circuit.
For this we will use a handy gate structure that allows us to tune the complexity of the
operation — and thus of the cost function.
More concretely, we initialize a qubit register in a random state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>
and apply a layer of Pauli-<span class="math notranslate nohighlight">\(Z\)</span> rotations <code class="docutils literal notranslate"><span class="pre">RZ</span></code> to all qubits, where all rotations are parametrized by the <em>same</em> angle <span class="math notranslate nohighlight">\(x\)</span>.
We then measure the expectation value of a random Hermitian observable <span class="math notranslate nohighlight">\(B\)</span> in the created
state, so that our cost function overall has the form</p>
<div class="math notranslate nohighlight">
\[E(x)=\langle\psi | U^\dagger(x) B U(x)|\psi\rangle.\]</div>
<p>Here, <span class="math notranslate nohighlight">\(U(x)\)</span> consists of a layer of <code class="docutils literal notranslate"><span class="pre">RZ</span></code> gates,</p>
<div class="math notranslate nohighlight">
\[U(x)=\prod_{a=1}^N R_Z^{(a)}(x) = \prod_{a=1}^N \exp\left(-i\frac{x}{2} Z_a\right).\]</div>
<p>Let’s implement such a cost function using PennyLane.
We begin with functions that generate the random initial state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>
and the random observable <span class="math notranslate nohighlight">\(B\)</span> for a given number of qubits <span class="math notranslate nohighlight">\(N\)</span> and a fixed seed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">unitary_group</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">rnd</span>


<span class="k">def</span> <span class="nf">random_state</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a random state on N qubits.&quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">unitary_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">N</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">rnd</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">states</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">random_observable</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a random observable on N qubits.&quot;&quot;&quot;</span>
    <span class="n">rnd</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="c1"># Generate real and imaginary part separately and (anti-)symmetrize them for Hermiticity</span>
    <span class="n">real_part</span><span class="p">,</span> <span class="n">imag_part</span> <span class="o">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">N</span><span class="p">,</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">real_part</span> <span class="o">+=</span> <span class="n">real_part</span><span class="o">.</span><span class="n">T</span>
    <span class="n">imag_part</span> <span class="o">-=</span> <span class="n">imag_part</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">real_part</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">imag_part</span>
</pre></div>
</div>
<p>Now let’s set up a “cost function generator”, namely a function that will create the
<code class="docutils literal notranslate"><span class="pre">cost</span></code> function we discussed above, using <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> as initial state and
measuring the expectation value of <span class="math notranslate nohighlight">\(B\)</span>. This generator has the advantage that
we can quickly create the cost function for various numbers of qubits — and therefore
cost functions with different complexity.</p>
<p>We will use the default qubit simulator with its JAX backend and also will rely
on the NumPy implementation of JAX.
To obtain precise results, we enable 64-bit <code class="docutils literal notranslate"><span class="pre">float</span></code> precision via the JAX config.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">jax.config</span> <span class="kn">import</span> <span class="n">config</span>

<span class="n">config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="s2">&quot;jax_enable_x64&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pennylane</span> <span class="k">as</span> <span class="nn">qml</span>

<span class="k">def</span> <span class="nf">make_cost</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a cost function on N qubits with N frequencies.&quot;&quot;&quot;</span>
    <span class="n">dev</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.device.html#pennylane.device" title="pennylane.device" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">device</span></a><span class="p">(</span><span class="s2">&quot;default.qubit&quot;</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

    <span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
    <span class="nd">@qml</span><span class="o">.</span><span class="n">qnode</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">interface</span><span class="o">=</span><span class="s2">&quot;jax&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">cost</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cost function on N qubits with N frequencies.&quot;&quot;&quot;</span>
        <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QubitStateVector.html#pennylane.QubitStateVector" title="pennylane.QubitStateVector" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">QubitStateVector</span></a><span class="p">(</span><span class="n">random_state</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">seed</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="n">dev</span><span class="o">.</span><span class="n">wires</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">dev</span><span class="o">.</span><span class="n">wires</span><span class="p">:</span>
            <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.RZ.html#pennylane.RZ" title="pennylane.RZ" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">RZ</span></a><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">wires</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
        <span class="k">return</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.expval.html#pennylane.expval" title="pennylane.expval" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">expval</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.Hermitian.html#pennylane.Hermitian" title="pennylane.Hermitian" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class"><span class="n">qml</span><span class="o">.</span><span class="n">Hermitian</span></a><span class="p">(</span><span class="n">random_observable</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">seed</span><span class="p">),</span> <span class="n">wires</span><span class="o">=</span><span class="n">dev</span><span class="o">.</span><span class="n">wires</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cost</span>
</pre></div>
</div>
<p>We also prepare some plotting functionalities and colors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Set a plotting range on the x-axis</span>
<span class="n">xlim</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">*</span><span class="n">xlim</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="c1"># Colors</span>
<span class="n">green</span> <span class="o">=</span> <span class="s2">&quot;#209494&quot;</span>
<span class="n">orange</span> <span class="o">=</span> <span class="s2">&quot;#ED7D31&quot;</span>
<span class="n">red</span> <span class="o">=</span> <span class="s2">&quot;xkcd:brick red&quot;</span>
<span class="n">blue</span> <span class="o">=</span> <span class="s2">&quot;xkcd:cerulean&quot;</span>
<span class="n">pink</span> <span class="o">=</span> <span class="s2">&quot;xkcd:bright pink&quot;</span>
</pre></div>
</div>
<p>Now that we took care of these preparations, let’s dive right into it:
It can be shown <a class="footnote-reference brackets" href="#genpar" id="id6">1</a> that <span class="math notranslate nohighlight">\(E(x)\)</span> takes the form of a
Fourier series in the variable <span class="math notranslate nohighlight">\(x\)</span>. That is to say that</p>
<div class="math notranslate nohighlight">
\[E(x) = a_0 + \sum_{\ell=1}^R a_{\ell}\cos(\ell x)+b_{\ell}\sin(\ell x).\]</div>
<p>Here, <span class="math notranslate nohighlight">\(a_{\ell}\)</span> and <span class="math notranslate nohighlight">\(b_{\ell}\)</span> are the <em>Fourier coefficients</em>.
If you would like to understand this a bit better still, have a read of
<a class="reference external" href="https://docs.pennylane.ai/en/stable/code/qml_fourier.html#module-pennylane.fourier" title="(in PennyLane v0.30)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fourier</span></code></a> and remember to check out the
<a class="reference internal" href="tutorial_expressivity_fourier_series.html"><span class="doc">Fourier module tutorial</span></a>.</p>
<p>Due to <span class="math notranslate nohighlight">\(B\)</span> being Hermitian, <span class="math notranslate nohighlight">\(E(x)\)</span> is a real-valued function, so
only positive frequencies and real coefficients appear in the Fourier series for <span class="math notranslate nohighlight">\(E(x)\)</span>.
This is true for any number of qubits (and therefore <code class="docutils literal notranslate"><span class="pre">RZ</span></code> gates) we use.</p>
<p>Using our function <code class="docutils literal notranslate"><span class="pre">make_cost</span></code> from above, we create the cost function for several
numbers of qubits and store both the function and its evaluations on the plotting range <code class="docutils literal notranslate"><span class="pre">X</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Qubit numbers</span>
<span class="n">Ns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="c1"># Fix a seed</span>
<span class="n">seed</span> <span class="o">=</span> <span class="mi">7658741</span>

<span class="n">cost_functions</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">evaluated_cost</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">Ns</span><span class="p">:</span>
    <span class="c1"># Generate the cost function for N qubits and evaluate it</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="n">make_cost</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
    <span class="n">evaluated_cost</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X</span><span class="p">])</span>
    <span class="n">cost_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
</pre></div>
</div>
<p>Let’s take a look at the created <span class="math notranslate nohighlight">\(E(x)\)</span> for the various numbers of qubits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Figure with multiple axes</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ns</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">E</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">evaluated_cost</span><span class="p">):</span>
    <span class="c1"># Plot cost function evaluations</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">green</span><span class="p">)</span>
    <span class="c1"># Axis and plot labels</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> qubits&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$x$&quot;</span><span class="p">)</span>

<span class="n">_</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$E$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_general_parshift_001.png" srcset="../_images/sphx_glr_tutorial_general_parshift_001.png" alt="1 qubits, 2 qubits, 4 qubits, 5 qubits" class = "sphx-glr-single-img"/><div class="line-block">
<div class="line"><br /></div>
</div>
<p>Indeed we see that <span class="math notranslate nohighlight">\(E(x)\)</span> is a periodic function whose complexity grows when increasing
<span class="math notranslate nohighlight">\(N\)</span> together with the number of <code class="docutils literal notranslate"><span class="pre">RZ</span></code> gates.
To take a look at the frequencies that are present in these functions, we may use
PennyLane’s <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/qml_fourier.html#module-pennylane.fourier" title="(in PennyLane v0.30)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">fourier</span></code></a> module.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The analysis tool <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.qnode_spectrum.html#pennylane.fourier.qnode_spectrum" title="(in PennyLane v0.30)"><code class="xref py py-func docutils literal notranslate"><span class="pre">qnode_spectrum()</span></code></a> makes use of the internal
structure of the <a class="reference external" href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="(in PennyLane v0.30)"><code class="xref py py-class docutils literal notranslate"><span class="pre">QNode</span></code></a> that encodes the cost function.
As we used the <code class="docutils literal notranslate"><span class="pre">jax.jit</span></code> decorator when defining the cost function above, we
here need to pass the wrapped function to <code class="docutils literal notranslate"><span class="pre">qnode_spectrum</span></code>, which is stored in
<code class="docutils literal notranslate"><span class="pre">cost_function.__wrapped__</span></code>.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane.fourier</span> <span class="kn">import</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.qnode_spectrum.html#pennylane.fourier.qnode_spectrum" title="pennylane.fourier.qnode_spectrum" class="sphx-glr-backref-module-pennylane-fourier sphx-glr-backref-type-py-function"><span class="n">qnode_spectrum</span></a>

<span class="n">spectra</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">N</span><span class="p">,</span> <span class="n">cost_function</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Ns</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">):</span>
    <span class="c1"># Compute spectrum with respect to parameter x</span>
    <span class="n">spec</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.qnode_spectrum.html#pennylane.fourier.qnode_spectrum" title="pennylane.fourier.qnode_spectrum" class="sphx-glr-backref-module-pennylane-fourier sphx-glr-backref-type-py-function"><span class="n">qnode_spectrum</span></a><span class="p">(</span><a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.QNode.html#pennylane.QNode" title="pennylane.QNode" class="sphx-glr-backref-module-pennylane sphx-glr-backref-type-py-class sphx-glr-backref-instance"><span class="n">cost_function</span><span class="o">.</span><span class="n">__wrapped__</span></a><span class="p">)(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="s2">&quot;x&quot;</span><span class="p">][()]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> qubits the spectrum is </span><span class="si">{</span><span class="n">spec</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="c1"># Store spectrum</span>
    <span class="n">spectra</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">freq</span> <span class="k">for</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">spec</span> <span class="k">if</span> <span class="n">freq</span><span class="o">&gt;</span><span class="mf">0.0</span><span class="p">])</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>For 1 qubits the spectrum is [-1.0, 0.0, 1.0].
For 2 qubits the spectrum is [-2.0, -1.0, 0.0, 1.0, 2.0].
For 4 qubits the spectrum is [-4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0].
For 5 qubits the spectrum is [-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0].
</pre></div>
</div>
<p>The number of positive frequencies that appear in <span class="math notranslate nohighlight">\(E(x)\)</span> is the same as the
number of <code class="docutils literal notranslate"><span class="pre">RZ</span></code> gates we used in the circuit! Recall that we only need to consider
the positive frequencies because <span class="math notranslate nohighlight">\(E(x)\)</span> is real-valued, and that we accounted for
the zero-frequency contribution in the coefficient <span class="math notranslate nohighlight">\(a_0\)</span>.
If you are interested why the number of gates coincides with the number of frequencies,
check out the <a class="reference internal" href="tutorial_expressivity_fourier_series.html"><span class="doc">Fourier module tutorial</span></a>.</p>
<p>Before moving on, let’s also have a look at the Fourier coefficients in the functions
we created:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pennylane.fourier.visualize</span> <span class="kn">import</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.visualize.bar.html#pennylane.fourier.visualize.bar" title="pennylane.fourier.visualize.bar" class="sphx-glr-backref-module-pennylane-fourier-visualize sphx-glr-backref-type-py-function"><span class="n">bar</span></a>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ns</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="n">spec</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">cost_functions</span><span class="p">,</span> <span class="n">spectra</span><span class="p">)):</span>
    <span class="c1"># Compute the Fourier coefficients</span>
    <span class="n">coeffs</span> <span class="o">=</span> <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.coefficients.html#pennylane.fourier.coefficients" title="pennylane.fourier.coefficients" class="sphx-glr-backref-module-pennylane-fourier sphx-glr-backref-type-py-function"><span class="n">qml</span><span class="o">.</span><span class="n">fourier</span><span class="o">.</span><span class="n">coefficients</span></a><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># Show the Fourier coefficients</span>
    <a href="https://docs.pennylane.ai/en/stable/code/api/pennylane.fourier.visualize.bar.html#pennylane.fourier.visualize.bar" title="pennylane.fourier.visualize.bar" class="sphx-glr-backref-module-pennylane-fourier-visualize sphx-glr-backref-type-py-function"><span class="n">bar</span></a><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axs</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">show_freqs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">colour_dict</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;real&quot;</span><span class="p">:</span> <span class="n">green</span><span class="p">,</span> <span class="s2">&quot;imag&quot;</span><span class="p">:</span> <span class="n">orange</span><span class="p">})</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Ns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2"> qubits&quot;</span><span class="p">)</span>
    <span class="c1"># Set x-axis labels</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">Ns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Frequency&quot;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s2">&quot;top&quot;</span><span class="p">)</span>
    <span class="c1"># Clean up y-axis labels</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">axs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">lab</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="s2">&quot;$a_\ell/2$&quot;</span><span class="p">,</span> <span class="s2">&quot;$b_\ell/2$&quot;</span><span class="p">])]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">axs</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_general_parshift_002.png" srcset="../_images/sphx_glr_tutorial_general_parshift_002.png" alt="1 qubits, 2 qubits, 4 qubits, 5 qubits" class = "sphx-glr-single-img"/><p>We find the real (imaginary) Fourier coefficients to be (anti-)symmetric.
This is expected because <span class="math notranslate nohighlight">\(E(x)\)</span> is real-valued and we again see why it is enough
to consider positive frequencies: the coefficients of the negative frequencies follow
from those of the positive frequencies.</p>
</div>
<div class="section" id="determining-the-full-dependence-on-x">
<h2>Determining the full dependence on <span class="math notranslate nohighlight">\(x\)</span><a class="headerlink" href="#determining-the-full-dependence-on-x" title="Permalink to this headline">¶</a></h2>
<p>Next we will show how to determine the <em>full</em> dependence of the cost function on <span class="math notranslate nohighlight">\(x\)</span>,
i.e., we will <em>reconstruct</em> <span class="math notranslate nohighlight">\(E(x)\)</span>.
The key idea is not new: Since <span class="math notranslate nohighlight">\(E(x)\)</span> is periodic with known, integer frequencies, we can
reconstruct it <em>exactly</em> by using trigonometric interpolation.
For this, we evaluate <span class="math notranslate nohighlight">\(E\)</span> at shifted positions <span class="math notranslate nohighlight">\(x_\mu\)</span>.
We will show the reconstruction both for <em>equidistant</em> and random shifts, corresponding to a
<a class="reference external" href="https://en.wikipedia.org/wiki/Discrete_Fourier_transform">uniform</a> and a
<a class="reference external" href="https://en.wikipedia.org/wiki/Non-uniform_discrete_Fourier_transform">non-uniform</a>
discrete Fourier transform (DFT), respectively.</p>
<div class="section" id="equidistant-shifts">
<h3>Equidistant shifts<a class="headerlink" href="#equidistant-shifts" title="Permalink to this headline">¶</a></h3>
<p>For the equidistant case we can directly implement the trigonometric interpolation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}x_\mu &amp;= \frac{2\mu\pi}{2R+1}\\
E(x) &amp;=\sum_{\mu=-R}^R E\left(x_\mu\right) \frac{\sin\left(\frac{2R+1}{2}(x-x_\mu)\right)} {(2R+1)\sin \left(\frac{1}{2} (x-x_\mu)\right)},\\\end{split}\]</div>
<p>where we reformulated <span class="math notranslate nohighlight">\(E\)</span> in the second expression using the
<a class="reference external" href="https://en.wikipedia.org/wiki/Sinc_function">sinc function</a> to enhance the numerical
stability. Note that we have to take care of a rescaling factor of <span class="math notranslate nohighlight">\(\pi\)</span> between
this definition of <span class="math notranslate nohighlight">\(\operatorname{sinc}\)</span> and the NumPy implementation <code class="docutils literal notranslate"><span class="pre">np.sinc</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When implementing <span class="math notranslate nohighlight">\(E\)</span>, we will replace</p>
<div class="math notranslate nohighlight">
\[\frac{\sin\left(\frac{2R+1}{2}(x-x_\mu)\right)} {(2R+1)\sin \left(\frac{1}{2} (x-x_\mu)\right)}\]</div>
<p>by</p>
<div class="math notranslate nohighlight">
\[\frac{\operatorname{sinc}\left(\frac{2R+1}{2}(x-x_\mu)\right)} {\operatorname{sinc} \left(\frac{1}{2} (x-x_\mu)\right)}\]</div>
<p>where the sinc function is defined as <span class="math notranslate nohighlight">\(\operatorname{sinc}(x)=\sin(x)/x\)</span>.
This enhances the numerical stability since <span class="math notranslate nohighlight">\(\operatorname{sinc}(0)=1\)</span>, so that the
denominator does no longer vanish at the shifted points.
Note that we have to take care of a rescaling factor of <span class="math notranslate nohighlight">\(\pi\)</span>
between this definition of <span class="math notranslate nohighlight">\(\operatorname{sinc}\)</span> and the NumPy implementation
<code class="docutils literal notranslate"><span class="pre">np.sinc</span></code>.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sinc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">full_reconstruction_equ</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct a univariate function with up to R frequencies using equidistant shifts.&quot;&quot;&quot;</span>
    <span class="c1"># Shift angles for the reconstruction</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">R</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># Shifted function evaluations</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fun</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">])</span>

    <span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">reconstruction</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Univariate reconstruction using equidistant shifts.&quot;&quot;&quot;</span>
        <span class="n">kernels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">sinc</span><span class="p">((</span><span class="n">R</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="n">kernels</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reconstruction</span>

<span class="n">reconstructions_equ</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">full_reconstruction_equ</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>
</pre></div>
</div>
<p>So how is this reconstruction doing? We will plot it along with the original function
<span class="math notranslate nohighlight">\(E\)</span>, mark the shifted evaluation points <span class="math notranslate nohighlight">\(x_\mu\)</span> (with crosses), and also show
its deviation from <span class="math notranslate nohighlight">\(E(x)\)</span> (lower plots).
For this, a function for the whole procedure of comparing the functions comes in handy, and
we will reuse it further below. For convenience, showing the deviation will be an optional
feature controled by the <code class="docutils literal notranslate"><span class="pre">show_diff</span></code> keyword argument.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">compare_functions</span><span class="p">(</span><span class="n">originals</span><span class="p">,</span> <span class="n">reconstructions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">shifts</span><span class="p">,</span> <span class="n">show_diff</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot two sets of functions next to each other and show their difference (in pairs).&quot;&quot;&quot;</span>
    <span class="c1"># Prepare the axes; we need fewer axes if we don&#39;t show the deviations</span>
    <span class="k">if</span> <span class="n">show_diff</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">originals</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mf">4.5</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">originals</span><span class="p">),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">_axs</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">show_diff</span> <span class="k">else</span> <span class="n">axs</span>

    <span class="c1"># Run over the functions and reconstructions</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">recon</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">_shifts</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">originals</span><span class="p">,</span> <span class="n">reconstructions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)):</span>
        <span class="c1"># Evaluate the original function and its reconstruction over the plotting range</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">X</span><span class="p">)))</span>
        <span class="n">E_rec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">recon</span><span class="p">,</span> <span class="n">X</span><span class="p">)))</span>
        <span class="c1"># Evaluate the original function at the positions used in the reconstruction</span>
        <span class="n">E_shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">_shifts</span><span class="p">)))</span>

        <span class="c1"># Show E, the reconstruction, and the shifts (top axes)</span>
        <span class="n">_axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">orange</span><span class="p">)</span>
        <span class="n">_axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">E_rec</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">green</span><span class="p">)</span>
        <span class="n">_axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">_shifts</span><span class="p">,</span> <span class="n">E_shifts</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">red</span><span class="p">)</span>
        <span class="c1"># Manage plot titles and xticks</span>
        <span class="n">_axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> qubits&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">show_diff</span><span class="p">:</span>
            <span class="c1"># [Optional] Show the reconstruction deviation (bottom axes)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">E</span> <span class="o">-</span> <span class="n">E_rec</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">blue</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;$x$&quot;</span><span class="p">)</span>
            <span class="c1"># Hide the xticks of the top x-axes if we use the bottom axes</span>
            <span class="n">_axs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>

    <span class="c1"># Manage y-axis labels</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">_axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$E$&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show_diff</span><span class="p">:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$E-E_</span><span class="si">{rec}</span><span class="s2">$&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span>

<span class="n">equ_shifts</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">Ns</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">compare_functions</span><span class="p">(</span><span class="n">cost_functions</span><span class="p">,</span> <span class="n">reconstructions_equ</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">equ_shifts</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_general_parshift_003.png" srcset="../_images/sphx_glr_tutorial_general_parshift_003.png" alt="1 qubits, 2 qubits, 4 qubits, 5 qubits" class = "sphx-glr-single-img"/><p><em>It works!</em></p>
</div>
<div class="section" id="non-equidistant-shifts">
<h3>Non-equidistant shifts<a class="headerlink" href="#non-equidistant-shifts" title="Permalink to this headline">¶</a></h3>
<p>Now let’s test the reconstruction with less regular sampling points on which to evaluate
<span class="math notranslate nohighlight">\(E\)</span>. This means we can no longer use the closed-form expression from above, but switch
to solving the set of equations</p>
<div class="math notranslate nohighlight">
\[E(x_\mu) = a_0 + \sum_{\ell=1}^R a_{\ell}\cos(\ell x_\mu)+b_{\ell}\sin(\ell x_\mu)\]</div>
<p>with the—now irregular—sampling points <span class="math notranslate nohighlight">\(x_\mu\)</span>.
For this, we set up the matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}C_{\mu\ell} = \begin{cases}
1 &amp;\text{ if } \ell=0\\
\cos(\ell x_\mu) &amp;\text{ if } 1\leq\ell\leq R\\
\sin(\ell x_\mu) &amp;\text{ if } R&lt;\ell\leq 2R,
\end{cases}\end{split}\]</div>
<p>collect the Fourier coefficients of <span class="math notranslate nohighlight">\(E\)</span> into the vector
<span class="math notranslate nohighlight">\(\boldsymbol{W}=(a_0, \boldsymbol{a}, \boldsymbol{b})\)</span>, and the evaluations of <span class="math notranslate nohighlight">\(E\)</span>
into another vector called <span class="math notranslate nohighlight">\(\boldsymbol{E}\)</span> so that</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{E} = C \boldsymbol{W} \Rightarrow \boldsymbol{W} = C^{-1}\boldsymbol{E}.\]</div>
<p>Let’s implement this right away! We will take the function and the shifts <span class="math notranslate nohighlight">\(x_\mu\)</span> as
inputs, inferring <span class="math notranslate nohighlight">\(R\)</span> from the number of the provided shifts, which is <span class="math notranslate nohighlight">\(2R+1\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">full_reconstruction_gen</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">shifts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct a univariate trigonometric function using arbitrary shifts.&quot;&quot;&quot;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="c1"># Construct the matrix C case by case</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">))</span>
    <span class="n">C3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">))</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">C1</span><span class="p">,</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">])</span>

    <span class="c1"># Evaluate the function to reconstruct at the shifted positions</span>
    <span class="n">evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)))</span>

    <span class="c1"># Solve the system of linear equations by inverting C</span>
    <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">@</span> <span class="n">evals</span>

    <span class="c1"># Extract the Fourier coefficients</span>
    <span class="n">a0</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="mi">1</span> <span class="p">:</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">W</span><span class="p">[</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>

    <span class="c1"># Construct the Fourier series</span>
    <span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">reconstruction</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Univariate reconstruction based on arbitrary shifts.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">*</span> <span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">frequencies</span> <span class="o">*</span> <span class="n">x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reconstruction</span>
</pre></div>
</div>
<p>To see this version of the reconstruction in action, we will sample the
shifts <span class="math notranslate nohighlight">\(x_\mu\)</span> at random in <span class="math notranslate nohighlight">\([-\pi,\pi)\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="n">rnd</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">for</span> <span class="n">N</span> <span class="ow">in</span> <span class="n">Ns</span><span class="p">]</span>
<span class="n">reconstructions_gen</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">full_reconstruction_gen</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">,</span> <span class="n">shifts</span><span class="p">))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">compare_functions</span><span class="p">(</span><span class="n">cost_functions</span><span class="p">,</span> <span class="n">reconstructions_gen</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">shifts</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_general_parshift_004.png" srcset="../_images/sphx_glr_tutorial_general_parshift_004.png" alt="1 qubits, 2 qubits, 4 qubits, 5 qubits" class = "sphx-glr-single-img"/><p>Again, we obtain a perfect reconstruction of <span class="math notranslate nohighlight">\(E(x)\)</span> up to numerical errors.
We see that the deviation from the original cost function became larger than for equidistant
shifts for some of the qubit numbers but it still remains much smaller than any energy scale of
relevance in applications.
The reason for these larger deviations is that some evaluation positions <span class="math notranslate nohighlight">\(x_\mu\)</span> were sampled
very close to each other, so that inverting the matrix <span class="math notranslate nohighlight">\(C\)</span> becomes less stable numerically.
Conceptually, we see that the reconstruction does <em>not</em> rely on equidistant evaluations points.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For some applications, the number of frequencies <span class="math notranslate nohighlight">\(R\)</span> is not known exactly but an upper
bound for <span class="math notranslate nohighlight">\(R\)</span> might be available. In this case, it is very useful that a reconstruction
that assumes <em>too many</em> frequencies in <span class="math notranslate nohighlight">\(E(x)\)</span> works perfectly fine.
However, it has the disadvantage of spending too many evaluations on the reconstruction,
and the number of required measurements, which is meaningful for the (time)
complexity of quantum algorithms, does so as well!</p>
</div>
</div>
</div>
<div class="section" id="differentiation-via-reconstructions">
<h2>Differentiation via reconstructions<a class="headerlink" href="#differentiation-via-reconstructions" title="Permalink to this headline">¶</a></h2>
<p>Next, we look at a modified reconstruction strategy that only obtains the odd or even part of
<span class="math notranslate nohighlight">\(E(x)\)</span>. This can be done by slightly modifying the shifted positions at which we
evaluate <span class="math notranslate nohighlight">\(E\)</span> and the kernel functions.</p>
<p>From a perspective of implementing the derivatives there are two approaches, differing in
which parts we derive on paper and which we leave to the computer:
In the first approach, we perform a partial reconstruction using the evaluations of the
original cost function <span class="math notranslate nohighlight">\(E\)</span> on the quantum computer, as detailed below.
This gives us a function implemented in <code class="docutils literal notranslate"><span class="pre">jax.numpy</span></code> and we may afterwards apply
<code class="docutils literal notranslate"><span class="pre">jax.grad</span></code> to this function and obtain the derivative function. <span class="math notranslate nohighlight">\(E(0)\)</span> then is only
one evaluation of this function away.
In the second approach, we compute the derivative of the partial reconstructions <em>manually</em> and
directly implement the resulting shift rule that multiplies the quantum computer evaluations with
coefficients and sums them up. This means that the partial reconstruction is not performed at
all by the classical computer, but only was used on paper to derive the formula for the
derivative.</p>
<p><em>Why do we look at both approaches?</em>, you might ask. That is because neither of them is
better than the other for <em>all</em> applications.
The first approach offers us derivatives of any order without additional manual work by
iteratively applying <code class="docutils literal notranslate"><span class="pre">jax.grad</span></code>, which is very convenient.
However, the automatic differentiation via JAX becomes increasingly expensive
with the order and we always reconstruct the <em>same</em> type of function, namely Fourier series,
so that computing the respective derivatives once manually and coding up the resulting
coefficients of the parameter-shift rule pays off in the long run. This is the strength of the
second approach.
We start with the first approach.</p>
<div class="section" id="automatically-differentiated-reconstructions">
<h3>Automatically differentiated reconstructions<a class="headerlink" href="#automatically-differentiated-reconstructions" title="Permalink to this headline">¶</a></h3>
<p>We implement the partial reconstruction method as a function; using PennyLane’s
automatic differentiation backends, this then enables us to obtain the derivatives at the point
of interest. For odd-order derivatives, we use the reconstruction of the odd part, for the
even-order derivatives that of the even part.</p>
<p>We make use of modified <a class="reference external" href="https://en.wikipedia.org/wiki/Dirichlet_kernel">Dirichlet kernels</a>
<span class="math notranslate nohighlight">\(\tilde{D}_\mu(x)\)</span> and equidistant shifts for this. For the odd reconstruction we have</p>
<div class="math notranslate nohighlight">
\[\begin{split}E_\text{odd}(x) &amp;= \sum_{\mu=1}^R E_\text{odd}(x_\mu) \tilde{D}_\mu(x)\\
\tilde{D}_\mu(x) &amp;= \frac{\sin(R (x-x_\mu))}{2R \tan\left(\frac{1}{2} (x-x_\mu)\right)} - \frac{\sin(R (x+x_\mu))}{2R \tan\left(\frac{1}{2} (x+x_\mu)\right)},\end{split}\]</div>
<p>which we can implement using the reformulation</p>
<div class="math notranslate nohighlight">
\[\frac{\sin(X)}{\tan(Y)}=\frac{X}{Y}\frac{\operatorname{sinc}(X)}{\operatorname{sinc}(Y)}\cos(Y)\]</div>
<p>for the kernel.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shifts_odd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">R</span><span class="p">:</span> <span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">mu</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
<span class="c1"># Odd linear combination of Dirichlet kernels</span>
<span class="n">D_odd</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="n">sinc</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
            <span class="o">-</span> <span class="n">sinc</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts_odd</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">odd_reconstruction_equ</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct the odd part of an ``R``-frequency input function via equidistant shifts.&quot;&quot;&quot;</span>
    <span class="n">evaluations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">fun</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">-</span> <span class="n">fun</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts_odd</span><span class="p">(</span><span class="n">R</span><span class="p">)])</span>

    <span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">reconstruction</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Odd reconstruction based on equidistant shifts.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluations</span><span class="p">,</span> <span class="n">D_odd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reconstruction</span>


<span class="n">odd_reconstructions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">odd_reconstruction_equ</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>
</pre></div>
</div>
<p>The even part on the other hand takes the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}E_\text{even}(x) &amp;= \sum_{\mu=0}^R E_\text{even}(x_\mu) \hat{D}_\mu(x)\\
\hat{D}_\mu(x) &amp;=
\begin{cases}
   \frac{\sin(Rx)}{2R \tan(x/2)} &amp;\text{if } \mu = 0 \\[12pt]
   \frac{\sin(R (x-x_\mu))}{2R \tan\left(\frac{1}{2} (x-x_\mu)\right)} + \frac{\sin(R (x+x_\mu))}{2R \tan\left(\frac{1}{2} (x+x_\mu)\right)} &amp; \text{if } \mu \in [R-1] \\[12pt]
   \frac{\sin(R (x-\pi))}{2R \tan\left(\frac{1}{2} (x-\pi)\right)} &amp; \text{if } \mu = R.
\end{cases}\end{split}\]</div>
<p>Note that not only the kernels <span class="math notranslate nohighlight">\(\hat{D}_\mu(x)\)</span> but also the shifted positions
<span class="math notranslate nohighlight">\(\{x_\mu\}\)</span> differ between the odd and even case.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shifts_even</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">R</span><span class="p">:</span> <span class="p">[</span><span class="n">mu</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">R</span> <span class="k">for</span> <span class="n">mu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">)]</span>
<span class="c1"># Even linear combination of Dirichlet kernels</span>
<span class="n">D_even</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
    <span class="p">[</span>
        <span class="p">(</span>
            <span class="n">sinc</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">sinc</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="n">sinc</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">shift</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts_even</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
    <span class="p">]</span>
<span class="p">)</span>
<span class="c1"># Special cases of even kernels</span>
<span class="n">D0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">sinc</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">sinc</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">Dpi</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">sinc</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">/</span> <span class="n">sinc</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">even_reconstruction_equ</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reconstruct the even part of ``R``-frequency input function via equidistant shifts.&quot;&quot;&quot;</span>
    <span class="n">_evaluations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">fun</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">+</span> <span class="n">fun</span><span class="p">(</span><span class="o">-</span><span class="n">shift</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts_even</span><span class="p">(</span><span class="n">R</span><span class="p">)])</span>
    <span class="n">evaluations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fun</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="o">*</span><span class="n">_evaluations</span><span class="p">,</span> <span class="n">fun</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)])</span>
    <span class="n">kernels</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">D0</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">),</span> <span class="o">*</span><span class="n">D_even</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">),</span> <span class="n">Dpi</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">R</span><span class="p">)])</span>

    <span class="nd">@jax</span><span class="o">.</span><span class="n">jit</span>
    <span class="k">def</span> <span class="nf">reconstruction</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Even reconstruction based on equidistant shifts.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">evaluations</span><span class="p">,</span> <span class="n">kernels</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">reconstruction</span>


<span class="n">even_reconstructions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">even_reconstruction_equ</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>
</pre></div>
</div>
<p>We also set up a function that performs both partial reconstructions and sums the resulting
functions to the full Fourier series.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">summed_reconstruction_equ</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sum an odd and an even reconstruction into the full function.&quot;&quot;&quot;</span>
    <span class="n">_odd_part</span> <span class="o">=</span> <span class="n">odd_reconstruction_equ</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="n">_even_part</span> <span class="o">=</span> <span class="n">even_reconstruction_equ</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reconstruction</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Full function based on separate odd/even reconstructions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_odd_part</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">_even_part</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">reconstruction</span>


<span class="n">summed_reconstructions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">summed_reconstruction_equ</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>
</pre></div>
</div>
<p>We show these even (blue) and odd (red) reconstructions and how they indeed
sum to the full function (orange, dashed).
We will again use the <code class="docutils literal notranslate"><span class="pre">compare_functions</span></code> utility from above for the comparison.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">matplotlib.lines</span> <span class="kn">import</span> <span class="n">Line2D</span>

<span class="c1"># Obtain the shifts for the reconstruction of both parts</span>
<span class="n">odd_and_even_shifts</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span>
        <span class="n">shifts_odd</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">shifts_even</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts_odd</span><span class="p">(</span><span class="n">R</span><span class="p">)))</span>
        <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shifts_odd</span><span class="p">(</span><span class="n">R</span><span class="p">)))</span>
        <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">Ns</span>
<span class="p">]</span>

<span class="c1"># Show the reconstructed parts and the sums</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">compare_functions</span><span class="p">(</span><span class="n">cost_functions</span><span class="p">,</span> <span class="n">summed_reconstructions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">,</span> <span class="n">odd_and_even_shifts</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">odd_recon</span><span class="p">,</span> <span class="n">even_recon</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">odd_reconstructions</span><span class="p">,</span> <span class="n">even_reconstructions</span><span class="p">)):</span>
    <span class="c1"># Odd part</span>
    <span class="n">E_odd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">odd_recon</span><span class="p">,</span> <span class="n">X</span><span class="p">)))</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">E_odd</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">red</span><span class="p">)</span>
    <span class="c1"># Even part</span>
    <span class="n">E_even</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">even_recon</span><span class="p">,</span> <span class="n">X</span><span class="p">)))</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">E_even</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">blue</span><span class="p">)</span>
    <span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;$E-(E_</span><span class="si">{odd}</span><span class="s2">+E_</span><span class="si">{even}</span><span class="s2">)$&quot;</span><span class="p">)</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">green</span><span class="p">,</span> <span class="n">red</span><span class="p">,</span> <span class="n">blue</span><span class="p">,</span> <span class="n">orange</span><span class="p">]</span>
<span class="n">styles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;--&#39;</span><span class="p">]</span>
<span class="n">handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">Line2D</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="n">ls</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.2</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">ls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">styles</span><span class="p">)]</span>
<span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Original&#39;</span><span class="p">,</span> <span class="s1">&#39;Odd reconstruction&#39;</span><span class="p">,</span> <span class="s1">&#39;Even reconstruction&#39;</span><span class="p">,</span> <span class="s1">&#39;Summed reconstruction&#39;</span><span class="p">]</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.89</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower left&#39;</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<img src="../_images/sphx_glr_tutorial_general_parshift_005.png" srcset="../_images/sphx_glr_tutorial_general_parshift_005.png" alt="tutorial general parshift" class = "sphx-glr-single-img"/><p>Great! The even and odd part indeed sum to the correct function again. But what did we
gain?</p>
<p>Nothing, actually, for the full reconstruction! Quite the opposite, we spent <span class="math notranslate nohighlight">\(2R\)</span>
evaluations of <span class="math notranslate nohighlight">\(E\)</span> on each part, that is <span class="math notranslate nohighlight">\(4R\)</span> evaluations overall to obtain a
description of the full function <span class="math notranslate nohighlight">\(E\)</span>! This is way more than the <span class="math notranslate nohighlight">\(2R+1\)</span>
evaluations needed for the full reconstructions from the beginning.</p>
<p>However, remember that we set out to compute derivatives of <span class="math notranslate nohighlight">\(E\)</span> at <span class="math notranslate nohighlight">\(0\)</span>, so that
for derivatives of odd/even order only the odd/even reconstruction is required.
Using an autodifferentiation framework, e.g. JAX, we can easily compute such higher-order
derivatives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># An iterative function computing the ``order``th derivative of a function ``f`` with JAX</span>
<span class="n">grad_gen</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="n">grad_gen</span><span class="p">(</span><span class="n">jax</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">f</span>

<span class="c1"># Compute the first, second, and fourth derivative</span>
<span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;First&quot;</span><span class="p">,</span> <span class="s2">&quot;Second&quot;</span><span class="p">,</span> <span class="s2">&quot;4th&quot;</span><span class="p">]):</span>
    <span class="n">recons</span> <span class="o">=</span> <span class="n">odd_reconstructions</span> <span class="k">if</span> <span class="n">order</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">even_reconstructions</span>
    <span class="n">recon_name</span> <span class="o">=</span> <span class="s2">&quot;odd &quot;</span> <span class="k">if</span> <span class="n">order</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">else</span> <span class="s2">&quot;even&quot;</span>
    <span class="n">cost_grads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grad_gen</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">order</span><span class="p">)(</span><span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">orig</span> <span class="ow">in</span> <span class="n">cost_functions</span><span class="p">])</span>
    <span class="n">recon_grads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grad_gen</span><span class="p">(</span><span class="n">recon</span><span class="p">,</span> <span class="n">order</span><span class="p">)(</span><span class="mf">0.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">recon</span> <span class="ow">in</span> <span class="n">recons</span><span class="p">])</span>
    <span class="n">all_equal</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;All entries match&quot;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">cost_grads</span><span class="p">,</span> <span class="n">recon_grads</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;Some entries differ!&quot;</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> derivatives via jax: </span><span class="si">{</span><span class="n">all_equal</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;From the cost functions:       &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cost_grads</span><span class="p">),</span> <span class="mi">6</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;From the </span><span class="si">{</span><span class="n">recon_name</span><span class="si">}</span><span class="s2"> reconstructions: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">recon_grads</span><span class="p">),</span> <span class="mi">6</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>First derivatives via jax: All entries match
From the cost functions:        [-0.689767 -2.463189  2.704583  1.935272]
From the odd  reconstructions:  [-0.689767 -2.463189  2.704583  1.935272]

Second derivatives via jax: All entries match
From the cost functions:        [ 0.26814   1.696854 -2.055918 -7.236953]
From the even reconstructions:  [ 0.26814   1.696854 -2.055918 -7.236953]

4th derivatives via jax: All entries match
From the cost functions:        [-0.26814  -6.938376 15.640123 53.355635]
From the even reconstructions:  [-0.26814  -6.938376 15.640123 53.355635]
</pre></div>
</div>
<p>The derivatives coincide.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While we used the <span class="math notranslate nohighlight">\(2R+1\)</span> evaluations <span class="math notranslate nohighlight">\(x_\mu=\frac{2\mu\pi}{2R+1}\)</span> for the full
reconstruction, derivatives only require <span class="math notranslate nohighlight">\(2R\)</span> calls to the respective circuit.
Also note that the derivatives can be computed at any position <span class="math notranslate nohighlight">\(x_0\)</span> other than
<span class="math notranslate nohighlight">\(0\)</span> by simply reconstructing the function <span class="math notranslate nohighlight">\(E(x+x_0)\)</span>, which again will be
a Fourier series like <span class="math notranslate nohighlight">\(E(x)\)</span>.</p>
</div>
</div>
<div class="section" id="id7">
<h3>Generalized parameter-shift rules<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>The second method is based on the previous one. Instead of consulting JAX, we may compute
the wanted derivative of the odd/even kernel function manually and thus derive general
parameter-shift rules from this. We will leave the technical derivation of these rules
to the paper <a class="footnote-reference brackets" href="#genpar" id="id8">1</a>. Start with the first derivative, which certainly is used the most:</p>
<div class="math notranslate nohighlight">
\[E'(0) = \sum_{\mu=1}^{2R} E\left(\frac{2\mu-1}{2R}\pi\right) \frac{(-1)^{\mu-1}}{4R\sin^2\left(\frac{2\mu-1}{4R}\pi\right)},\]</div>
<p>This is straight-forward to implement by defining the coefficients and evaluating
<span class="math notranslate nohighlight">\(E\)</span> at the shifted positions <span class="math notranslate nohighlight">\(x_\mu\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parameter_shift_first</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the first-order derivative of a function with R frequencies at 0.&quot;&quot;&quot;</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span>
    <span class="c1"># Classically computed coefficients</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">mu</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">R</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shifts</span><span class="p">)]</span>
    <span class="p">)</span>
    <span class="c1"># Evaluations of the cost function E(x_mu)</span>
    <span class="n">evaluations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">shifts</span><span class="p">)))</span>
    <span class="c1"># Contract coefficients with evaluations</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">evaluations</span><span class="p">)</span>

<span class="n">ps_der1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">parameter_shift_first</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>
</pre></div>
</div>
<p>The second-order derivative takes a similar form, but we have to take care of the evaluation at
<span class="math notranslate nohighlight">\(0\)</span> and the corresponding coefficient separately:</p>
<div class="math notranslate nohighlight">
\[E''(0) = -E(0)\frac{2R^2+1}{6} - \sum_{\mu=1}^{2R-1} E\left(\frac{\mu\pi}{R}\right)\frac{(-1)^\mu}{2\sin^2 \left(\frac{\mu\pi}{2R}\right)}.\]</div>
<p>Let’s code this up, again we only get slight complications from the special evaluation
at <span class="math notranslate nohighlight">\(0\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parameter_shift_second</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the second-order derivative of a function with R frequencies at 0.&quot;&quot;&quot;</span>
    <span class="n">shifts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R</span><span class="p">)</span>
    <span class="c1"># Classically computed coefficients for the main sum</span>
    <span class="n">_coeffs</span> <span class="o">=</span> <span class="p">[(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">mu</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">mu</span><span class="p">,</span> <span class="n">shift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shifts</span><span class="p">)]</span>
    <span class="c1"># Include the coefficients for the &quot;special&quot; term E(0).</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">]</span> <span class="o">+</span> <span class="n">_coeffs</span><span class="p">)</span>
    <span class="c1"># Evaluate at the regularily shifted positions</span>
    <span class="n">_evaluations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">shifts</span><span class="p">))</span>
    <span class="c1"># Include the &quot;special&quot; term E(0).</span>
    <span class="n">evaluations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fun</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)]</span> <span class="o">+</span> <span class="n">_evaluations</span><span class="p">)</span>
    <span class="c1"># Contract coefficients with evaluations.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">evaluations</span><span class="p">)</span>

<span class="n">ps_der2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">parameter_shift_second</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">,</span> <span class="n">Ns</span><span class="p">))</span>
</pre></div>
</div>
<p>We will compare these two shift rules to the finite-difference derivative commonly used for
numerical differentiation. We choose a finite difference of <span class="math notranslate nohighlight">\(d_x=5\times 10^{-5}\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dx</span> <span class="o">=</span> <span class="mf">5e-5</span>

<span class="k">def</span> <span class="nf">finite_diff_first</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the first order finite difference derivative.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">fun</span><span class="p">(</span><span class="o">-</span><span class="n">dx</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="n">dx</span>

<span class="n">fd_der1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">finite_diff_first</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">finite_diff_second</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the second order finite difference derivative.&quot;&quot;&quot;</span>
    <span class="n">fun_p</span><span class="p">,</span> <span class="n">fun_0</span><span class="p">,</span> <span class="n">fun_m</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">dx</span><span class="p">),</span> <span class="n">fun</span><span class="p">(</span><span class="mf">0.0</span><span class="p">),</span> <span class="n">fun</span><span class="p">(</span><span class="o">-</span><span class="n">dx</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">fun_p</span> <span class="o">-</span> <span class="n">fun_0</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span> <span class="o">-</span> <span class="p">(</span><span class="n">fun_0</span> <span class="o">-</span> <span class="n">fun_m</span><span class="p">)</span><span class="o">/</span><span class="n">dx</span><span class="p">)</span> <span class="o">/</span><span class="n">dx</span>

<span class="n">fd_der2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">finite_diff_second</span><span class="p">,</span> <span class="n">cost_functions</span><span class="p">))</span>
</pre></div>
</div>
<p>All that is left is to compare the computed parameter-shift and finite-difference
derivatives:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of qubits/RZ gates:         &quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">Ns</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">9</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First-order parameter-shift rule:  </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ps_der1</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First-order finite difference:     </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fd_der1</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Second-order parameter-shift rule: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ps_der2</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Second-order finite difference:    </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fd_der2</span><span class="p">),</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="sphx-glr-script-out">Out:</p>
<div class="sphx-glr-script-out highlight-none notranslate"><div class="highlight"><pre><span></span>Number of qubits/RZ gates:                  1         2         4         5
First-order parameter-shift rule:  [-0.689767 -2.463189  2.704583  1.935272]
First-order finite difference:     [-0.689767 -2.463189  2.704583  1.935272]
Second-order parameter-shift rule: [ 0.26814   1.696854 -2.055918 -7.236953]
Second-order finite difference:    [ 0.268141  1.696854 -2.055919 -7.236953]
</pre></div>
</div>
<p>The parameter-shift rules work as expected! And we were able to save
a circuit evaluation as compared to a full reconstruction.</p>
<p>And this is all we want to show here about univariate function reconstructions and generalized
parameter shift rules.
Note that the techniques above can partially be extended to frequencies that are not
integer-valued, but many closed form expressions are no longer valid.
For the reconstruction, the approach via Dirichlet kernels no longer works in the general
case; instead, a system of equations has to be solved, but with generalized
frequencies <span class="math notranslate nohighlight">\(\{\Omega_\ell\}\)</span> instead of <span class="math notranslate nohighlight">\(\{\ell\}\)</span> (see e.g.
Sections III A-C in <a class="footnote-reference brackets" href="#genpar" id="id9">1</a>)</p>
</div>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<dl class="footnote brackets">
<dt class="label" id="genpar"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>,<a href="#id6">3</a>,<a href="#id8">4</a>,<a href="#id9">5</a>)</span></dt>
<dd><p>David Wierichs, Josh Izaac, Cody Wang, Cedric Yen-Yu Lin.
“General parameter-shift rules for quantum gradients”.
<a class="reference external" href="https://arxiv.org/abs/2107.12390">arXiv preprint arXiv:2107.12390</a>.</p>
</dd>
<dt class="label" id="calcpqc"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Javier Gil Vidal, Dirk Oliver Theis. “Calculus on parameterized quantum circuits”.
<a class="reference external" href="https://arxiv.org/abs/1812.06323">arXiv preprint arXiv:1812.06323</a>.</p>
</dd>
<dt class="label" id="rotosolve"><span class="brackets">3</span></dt>
<dd><p>Mateusz Ostaszewski, Edward Grant, Marcello Benedetti.
“Structure optimization for parameterized quantum circuits”.
<a class="reference external" href="https://arxiv.org/abs/1905.09692">arXiv preprint arXiv:1905.09692</a>.</p>
</dd>
<dt class="label" id="algeshift"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>Artur F. Izmaylov, Robert A. Lang, Tzu-Ching Yen.
“Analytic gradients in variational quantum algorithms: Algebraic extensions of the parameter-shift rule to general unitary transformations”.
<a class="reference external" href="https://arxiv.org/abs/2107.08131">arXiv preprint arXiv:2107.08131</a>.</p>
</dd>
<dt class="label" id="gendiffrules"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>Oleksandr Kyriienko, Vincent E. Elfving.
“Generalized quantum circuit differentiation rules”.
<a class="reference external" href="https://arxiv.org/abs/2108.01218">arXiv preprint arXiv:2108.01218</a>.</p>
</dd>
</dl>
</div>
<div class="section" id="about-the-author">
<h2>About the author<a class="headerlink" href="#about-the-author" title="Permalink to this headline">¶</a></h2>
<div class="bio" >
    <div class="photo" >
        <img class="photo__img" src="../_static/authors/david_wierichs.jpg" alt="David Wierichs" >
    </div>
    <div class="bio-text">
        <h4 class="bio-text__author-name">David Wierichs</h4>
        <p class="bio-text__author-description">David is a researcher and quantum software developer at Xanadu, who likes to think about quantum gradients and how to use them in variational quantum algorithms. He enjoys sharing ideas in science and open source software and likes implementing cool stuff in PennyLane.</p>
    </div>
</div><p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 3 minutes  11.405 seconds)</p>
<div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-demos-tutorial-general-parshift-py">
<div class="sphx-glr-download sphx-glr-download-python docutils container">
<p><a class="reference download internal" download="" href="../_downloads/0adc26e3a770a20efb8ebcb6600531e5/tutorial_general_parshift.py"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Python</span> <span class="pre">source</span> <span class="pre">code:</span> <span class="pre">tutorial_general_parshift.py</span></code></a></p>
</div>
<div class="sphx-glr-download sphx-glr-download-jupyter docutils container">
<p><a class="reference download internal" download="" href="../_downloads/5eeb244f826624cc204d84f65337b9f9/tutorial_general_parshift.ipynb"><code class="xref download docutils literal notranslate"><span class="pre">Download</span> <span class="pre">Jupyter</span> <span class="pre">notebook:</span> <span class="pre">tutorial_general_parshift.ipynb</span></code></a></p>
</div>
</div>
<p class="sphx-glr-signature"><a class="reference external" href="https://sphinx-gallery.github.io">Gallery generated by Sphinx-Gallery</a></p>
</div>
</div>


    <script type="text/javascript">
        // This script ensures that the active navbar entry switches
        // from 'QML' to 'Demos' for any webpage within the demos/ directory,
        // or for any of the demonstration landing pages
        // (e.g., demos_optimization).
        var pagename = document.location.href.match(/[^\/]+$/)[0];
        var dir = document.URL.substr(0,document.URL.lastIndexOf('/')).match(/[^\/]+$/)[0];

        if (pagename.includes("demos") || pagename.includes("demonstrations") || dir.includes("demos")) {

            $(".nav-item.active").removeClass("active");
            var demos_link = $('.navbar-nav a').filter(function(index) { return $(this).text() === "Demos"; })[0]
            $(demos_link).parent().addClass("active");
        }
    </script>

              <div id="bottom-dl" class="xanadu-call-to-action-links">
                <div id="tutorial-type">demos/tutorial_general_parshift</div>
                <div class="download-python-link">
                  <i class="fab fa-python"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Python script</div>
                </div>
                <div class="download-notebook-link">
                  <i class="fas fa-download"></i>&nbsp;
                  <div class="call-to-action-desktop-view">Download Notebook</div>
                </div>
                <div class="github-view-link">
                  <i class="fab fa-github"></i>&nbsp;
                  <div class="call-to-action-desktop-view">View on GitHub</div>
                </div>
              </div>

            </div>
            
          </div>
        
<div class="localtoc-container nano has-scrollbar">
  <div class="nano-content">
    <div id="localtoc">
        
          <h3>Contents</h3>
          <!-- Display the ToC for the current document if it is not empty. -->
          <ul class='current'>
<li class='current'><a class="reference internal" href="#">Generalized parameter-shift rules</a><ul class='current'>
<li class='current'><a class="reference internal" href="#cost-functions-arising-from-quantum-gates">Cost functions arising from quantum gates</a></li>
<li class='current'><a class="reference internal" href="#determining-the-full-dependence-on-x">Determining the full dependence on <span class="math notranslate nohighlight">\(x\)</span></a><ul class='current'>
<li class='current'><a class="reference internal" href="#equidistant-shifts">Equidistant shifts</a></li>
<li class='current'><a class="reference internal" href="#non-equidistant-shifts">Non-equidistant shifts</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#differentiation-via-reconstructions">Differentiation via reconstructions</a><ul class='current'>
<li class='current'><a class="reference internal" href="#automatically-differentiated-reconstructions">Automatically differentiated reconstructions</a></li>
<li class='current'><a class="reference internal" href="#id7">Generalized parameter-shift rules</a></li>
</ul>
</li>
<li class='current'><a class="reference internal" href="#references">References</a></li>
<li class='current'><a class="reference internal" href="#about-the-author">About the author</a></li>
</ul>
</li>
</ul>

        
    </div>

    <div class="xanadu-call-to-action-links">
        <h3>Downloads</h3>
        <div id="tutorial-type">demos/tutorial_general_parshift</div>
        <div class="download-python-link">
            <i class="fab fa-python"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Python script</div>
        </div>
        <div class="download-notebook-link">
            <i class="fas fa-download"></i>&nbsp;
            <div class="call-to-action-desktop-view">Download Notebook</div>
        </div>
        <div class="github-view-link">
            <i class="fab fa-github"></i>&nbsp;
            <div class="call-to-action-desktop-view">View on GitHub</div>
        </div>
    </div>
    <div id="related-tutorials" class="mt-4">
      <h3> Related</h3>
    </div>
  </div>
</div>


    
          <div class="up-button">
            
              
                <a href="../demos_optimization.html"><i class="fas fa-angle-double-left"></i></a>
              
            
          </div>

          <div class="clearfix"></div>
        </div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="tutorial_doubly_stochastic.html" title="Doubly stochastic gradient descent"
             >next</a> |</li>
        <li class="right" >
          <a href="tutorial_spsa.html" title="Optimization using SPSA"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">PennyLane  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../quantum-computing.html" >Quantum Computing</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="../demonstrations.html" >Demos</a> &#187;</li>
          <li class="nav-item nav-item-3"><a href="../demos_optimization.html" >Optimization</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Generalized parameter-shift rules</a></li> 
      </ul>
    </div>
  <script type="text/javascript">
    $("#mobile-toggle").click(function () {
      $("#left-column").slideToggle("slow");
    });
  </script>

  <!-- jQuery -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
  <!-- MathJax -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <!-- Bootstrap core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
  <!-- MDB core JavaScript -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.8.10/js/mdb.min.js"></script>
  <!-- NanoScroller -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery.nanoscroller/0.8.7/javascripts/jquery.nanoscroller.min.js"></script>
  <!-- Syntax Highlighting -->
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
  <script type="text/javascript">hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript">
    $("a.reference.internal").each(function(){
      var link = $(this).attr("href");

      var hash = link.split("#")[1];
      var page = link.split("#")[0].split("/").slice(-1)[0].replace(".html", "");

      if (hash == page) {
        $(this).attr("href", link.split("#")[0]);
      }
    });

    $(".document > .section").removeClass("section");
    $("h1 ~ .section").removeClass("section");
    $(".localtoc-container .nano-content").css("height", $("#content").height());
    $(".localtoc-container").css("height", $("#content").height());
    $(".nano").nanoScroller();
  </script>

  <script type="text/javascript">
      $(window).scroll(function(){
        var scrollBottom = $(document).height() - $(window).height() - $(window).scrollTop();
        if (scrollBottom < 342) {
          $(".localtoc-container").css("height", "calc(100% - " + (342 - scrollBottom) + "px)");
          $(".localtoc-container .nano-content").css("height", "calc(100% - 119px)");
        }
      });
  </script>

  <script type="text/javascript">
    if ($(".current").length) {
      var target = $(".current")[0]
      var rect = target.getBoundingClientRect();
      if (rect.bottom > window.innerHeight) {
          $(".nano").nanoScroller({ scrollTo: $(".current") });
      } else {
          $(".nano").nanoScroller({ scrollTop: 0 });
      }
    }
    $(document).ready(function () {
        $(".css-transitions-only-after-page-load").each(function (index, element) {
            setTimeout(function () { $(element).removeClass("css-transitions-only-after-page-load") }, 10);
        });
        if (window.location.hash) {
          var target = $("[id='" + window.location.hash.substr(1) + "']");
          if (target.closest(".collapse").length) {
            target.closest(".collapse").addClass("show");
            target.closest(".collapse").prev().find(".rotate").addClass("up");
          }
        }
    });
  </script>

    <script type="text/javascript">
    var downloadNote = $(".sphx-glr-download-link-note.admonition.note");
    if (downloadNote.length >= 1) {
      var tutorialUrlArray = $("#tutorial-type").text().split('/');

      if (tutorialUrlArray[0] == "demos") {
        tutorialUrlArray[0] = "demonstrations";
      }

      var githubLink = "https://github.com/" + "PennyLaneAI/qml" + "/blob/master/" + tutorialUrlArray.join("/") + ".py",
          pythonLink = $(".sphx-glr-download .reference.download")[0].href,
          notebookLink = $(".sphx-glr-download .reference.download")[1].href;

      $(".download-python-link").wrap("<a href=" + pythonLink + " data-behavior='call-to-action-event' data-response='Download Python script' download target='_blank'/>");
      $(".download-notebook-link").wrap("<a href=" + notebookLink + " data-behavior='call-to-action-event' data-response='Download Notebook' download target='_blank'/>");
      $(".github-view-link").wrap("<a href=" + githubLink + " data-behavior='call-to-action-event' data-response='View on Github' target='_blank'/>");
      $("#right-column").addClass("page-shadow");
    } else {
      $(".xanadu-call-to-action-links").hide();
      $("#bottom-dl").attr('style','display: none !important');
    }
    </script>

    <script type="text/javascript">
      function makeUL(urls, text) {
          var list = document.createElement('ul');

          for (var i = 0; i < urls.length; i++) {
              var item = document.createElement('li');
              var a = document.createElement('a');
              var linkText = document.createTextNode(text[i]);
              a.appendChild(linkText);
              a.href = urls[i];
              item.appendChild(a);
              list.appendChild(item);
          }
          return list;
      }

      if (typeof related_tutorials !== 'undefined') {
          document.getElementById('related-tutorials').appendChild(makeUL(related_tutorials, related_tutorials_titles));
          $("#related-tutorials ul li a").append(' <i class="fas fa-angle-double-right" style="font-size: smaller;"></i>')
          $("#related-tutorials").show();

    } else {
          $("#related-tutorials").hide();
    }
    </script>

  <!-- Account for MathJax when navigating to anchor tags. -->
  <script type="text/javascript">
    function scrollToElement(e) {
      // Scrolls to the given element, taking into account the navbar.
      MathJax.Hub.Queue(function() {
        // The following MUST be done asynchronously to take effect.
        setTimeout(function() {
          const navbar = document.querySelector("nav.navbar");
          const navbarHeight = navbar ? navbar.offsetHeight : 0;
          const scrollToY = e.offsetTop + e.offsetParent.offsetTop - navbarHeight;
          window.scrollTo(0, scrollToY);
        }, 0);
      });
    }

    function scrollToFragment(fragment) {
      // Scrolls to the position of the given URL fragment (which includes the "#").
      const elementID = fragment.replace(".", "\\.");
      if (elementID !== "") {
        const element = document.querySelector(elementID);
        if (element !== null) {
          scrollToElement(element);
        }
      }
    }

    $(document).ready(() => {
      scrollToFragment(window.location.hash);
      window.addEventListener("popstate", (_) => scrollToFragment(document.location.hash), false);
    });
  </script>

  <!-- Hide the rendering of :orphan: metadata. -->
  <script type="text/javascript">
    $(document).ready(() => {
      const elements = document.getElementsByClassName("field-odd");
      for (const element of elements) {
          if (element.innerHTML.trim() === "orphan") {
            element.style.display = "none";
          }
      }
    });
  </script>

  <script type="text/javascript">
    jQuery.noConflict(true);
  </script>

  

<footer class="page-footer text-md-left pt-4">

  <hr class="pb-0 mb-0">
  <div class="container-fluid">
    <div class="row justify-content-md-center">

      
      <!-- About -->
      <div class="col-md-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <p>        PennyLane is an open-source software framework for quantum
        machine learning, quantum chemistry, and quantum computing, 
        with the ability to run on all hardware.
        Maintained with ❤️ by Xanadu.
        </p>
      </div>
      

      <!-- Links -->
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">PennyLane</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://pennylane.ai/">Home</a></li>
          
          <li><a href="https://pennylane.ai/qml">Learn</a></li>
          
          <li><a href="https://pennylane.ai/qml/demonstrations.html">Demonstrations</a></li>
          
          <li><a href="https://docs.pennylane.ai/">Documentation</a></li>
          
          <li><a href="https://github.com/PennyLaneAI/pennylane">GitHub</a></li>
          
          <li><a href="https://twitter.com/pennylaneai">Twitter</a></li>
          
          <li><a href="https://pennylane.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      
      <div class="col-md-2 col-4">
        <h5 class="mb-1 footer-heading">Xanadu</h5>
        <hr width=100px class="d-inline-block mt-0 mb-1 accent-4">
        <ul class="list-unstyled">
          
          <li><a href="https://xanadu.ai/">Home</a></li>
          
          <li><a href="https://xanadu.ai/about/">About</a></li>
          
          <li><a href="https://xanadu.ai/photonics">Hardware</a></li>
          
          <li><a href="https://xanadu.ai/careers/">Careers</a></li>
          
          <li><a href="https://cloud.xanadu.ai">Cloud</a></li>
          
          <li><a href="https://discuss.pennylane.ai/">Forum</a></li>
          
          <li><a href="https://xanadu.ai/blog">Blog</a></li>
          
        </ul>
      </div>
      

    </div>
  </div>
  <hr>

  <!-- Social -->
  <div class="social-section text-center">
      <ul class="list-unstyled list-inline mb-0">
          
          <li class="list-inline-item"><a class="btn-git" href="https://twitter.com/PennyLaneAI"><i class="fab fa-twitter"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://github.com/PennyLaneAI/pennylane"><i class="fab fa-github"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://linkedin.com/company/xanaduai/"><i class="fab fa-linkedin-in"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://discuss.pennylane.ai"><i class="fab fa-discourse"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://xanadu-quantum.slack.com/join/shared_invite/zt-nkwn25v9-H4hituCb_PUj4idG0MhSug#/shared-invite/email"><i class="fab fa-slack"> </i></a></li>
          
          <li class="list-inline-item"><a class="btn-git" href="https://pennylane.ai/blog/"><i class="fas fa-rss"> </i></a></li>
          
      </ul>
      
        
          <a href="https://xanadu.us17.list-manage.com/subscribe?u=725f07a1d1a4337416c3129fd&id=294b062630" style="font-size: initial;">
            Stay updated with our newsletter
          </a>
        
      
  </div>

  <!-- Copyright -->
  <div class="footer-copyright py-3 mt-0 text-center">
      <div class="container-fluid">
            Copyright &copy; 2022, Xanadu Quantum Technologies, Inc.

        
          <br>
          TensorFlow, the TensorFlow logo, and any related marks are trademarks of Google Inc.
        
      </div>
  </div>
</footer>
  </body>
</html>

.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/tutorial_optimal_control.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_demos_tutorial_optimal_control.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_tutorial_optimal_control.py:


Optimal control for gate compilation
====================================

.. meta::
    :property="og:description": Optimize pulse programs to obtain digital gates.
    :property="og:image": https://pennylane.ai/qml/_images/thumbnail_tutorial_optimal_control.png

.. related::

    tutorial_pulse_programming101 Introduction to pulse programming in PennyLane
    tutorial_neutral_atoms Introduction to neutral atom quantum computers
    ahs_aquila Pulse programming on Rydberg atom hardware



Today, quantum computations are largely phrased in the language of quantum circuits,
composed of digital quantum gates.
However, most quantum hardware does not come with such digital
gates as elementary native operations.
Instead, the hardware allows us to play sequences of analog electromagnetic pulses,
for example by shining laser pulses on trapped ions or Rydberg atoms, or by sending microwave
pulses onto superconducting qubit cavities.
These pulses need to be calibrated to produce the desired digital gates, and in
this tutorial we will be concerned with exactly this task.

For this, we will parametrize a pulse sequence, which leads to a whole *space*
of possible sequences. Then we optimize the pulse parameters in order to
find a configuration in this space that behaves as closely to the target gate
as possible.
More concretely, we will optimize simple pulse programs on two and three qubits to
obtain a CNOT and a Toffoli gate.
This training of control parameters to achieve a specific time
evolution is a standard task in the field of *quantum optimal control*.

|

.. figure:: ../demonstrations/optimal_control/OptimalControl_control_quantum_systems.png
    :align: center
    :width: 100%
    :alt: Illustration of a metal hand crafting a CNOT gate, using qubit systems
    :target: javascript:void(0);

|

For an introduction, see
:doc:`the demo on differentiable pulse programming </demos/tutorial_pulse_programming101>`
in PennyLane.
Instead of optimizing pulses to yield digital quantum gates,
we may use them directly to solve optimization problems, as is also showcased in this
introductory demo. If you are interested in specific hardware pulses, take a look at
:doc:`an introduction to neutral-atom quantum computing </demos/tutorial_neutral_atoms>`
or :doc:`the tutorial on the QuEra Aquila device </demos/ahs_aquila>`, which treat pulse
programming with Rydberg atoms.

Quantum optimal control
-----------------------

The overarching goal of quantum optimal control is to find the best way to steer
a microscopical physical system such that its dynamics matches a desired behaviour.
The meaning of "best" and "desired behaviour" will depend on the specific
task, and it is important to specify the underlying assumptions and constraints on
the system controls in order to make the problem statement well-defined.
Once we specified all these details, optimal control theory is concerned with
questions like
"How close can the system get to modelling the desired behaviour?",
"How can we find the best (sequence of) control parameters to obtain the desired behaviour?",
or
"What is the shortest time in which the system can reach a specific state, given some
initial state?" (controlling at the so-called quantum speed limit) [#CanevaMurphy09]_.

In this tutorial, we consider the control of few-qubit systems through pulse sequences,
with the goal to produce a given target, namely a digital gate, to the highest possible
precision.
To do this, we will choose an ansatz for the pulse sequence that contains
free parameters and define a profit function that quantifies the similarity between
the qubit operation and the target gate.
Then, we maximize this function by optimizing the pulse parameters until we
find the desired gate to a sufficient precision--or can no longer improve on the
approximation we found.
For the training phase, we will make use of fully-differentiable classical simulations
of the qubit dynamics, allowing us to make use of backpropagation -- an efficient
differentiation technique widely used in machine learning -- and gradient-based
optimization.
At the same time we attempt to find pulse shapes and control parameters that are
(to some degree) realistically feasible, including bounded
pulse amplitudes and rates of change of the amplitudes.

Tutorials that use other techniques are available, for example, for the
`open-source quantum toolbox QuTiP <https://qutip.org/qutip-tutorials/#optimal-control>`__.

Gate calibration via pulse programming
--------------------------------------

Here, we briefly discuss the general setup of pulse programs that we will use for our
optimal control application. For more details, you may peruse the related
tutorials focusing on pulse programming.

Consider a quantum system comprised of :math:`n` two-level systems, or qubits, described
by a Hamiltonian

.. math::

    H(\boldsymbol{p}, t) = H_d + \sum_{i=1}^K f_i(\boldsymbol{p_i}, t) H_i.

As we can see, :math:`H` depends on the time :math:`t` and on a set of control parameters
:math:`\boldsymbol{p}`, which is composed of one parameter vector :math:`\boldsymbol{p_i}`
per term. Both :math:`t` and :math:`\boldsymbol{p}`
feed into functions :math:`f_i` that return scalar coefficients
for the (constant) Hamiltonian terms :math:`H_i`. In addition, there is a constant drift
Hamiltonian :math:`H_d`.
We will assume that the Hamiltonian :math:`H` fully describes the system of interest and,
in particular, we do not consider sources of noise in the system, such as leakage, dephasing,
or crosstalk, i.e. the accidental interaction with other parts of a larger, surrounding system.

The time evolution of the state of our quantum system will be described
by the Schrödinger equation associated with :math:`H`.
However, for our purposes it will be more useful to consider the full unitary evolution that
the Hamiltonian causes, independently of the initial state. This way, we can compare it to
the digital target gate without iterating over different input and output states.
The Schrödinger equation dictates the behaviour of the evolution operator :math:`U` to be

.. math::

    \frac{d}{dt} U(\boldsymbol{p}, t) = -i H(\boldsymbol{p}, t) U(\boldsymbol{p}, t),

where we implicitly fixed the initial time of the evolution to :math:`t_0=0`.
It is possible to simulate the dynamics of sufficiently small quantum systems on
a classical computer by solving the ordinary differential equation (ODE) above numerically.
For a fixed pulse duration :math:`T` and given control parameters :math:`\boldsymbol{p}`,
a numerical ODE solver computes the matrix :math:`U(\boldsymbol{p}, T)`.

How can we tell whether the evolution of the qubit system is close to the digital gate
we aim to produce? We will need a measure of similarity, or fidelity.

In this tutorial we will describe the similarity of two unitary matrices :math:`U` and
:math:`V` on :math:`n` qubits with a fidelity function:

.. math::

    f(U,V) = \frac{1}{2^n}\big|\operatorname{tr}(U^\dagger V)\big|.

It is similar to an overlap measure obtained from the
`Frobenius norm <https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm>`__
but it allows us to ignore differences in the global phase.
Note that fidelity is often used to compare quantum states rather than gates,
and that noise often plays a role in this context. Here we only consider unitary
gates.

We can maximize the fidelity function above to train the pulse parameters. For this
purpose we write

.. math::

    F(\boldsymbol{p}) \equiv f(U_\text{target}, U(\boldsymbol{p}, T)).

Here :math:`U_\text{target}` is the unitary matrix of the gate that we want to compile.
We consider the total duration :math:`T` as a fixed constraint to the optimization
problem and therefore we do not denote it as a free parameter of :math:`F`.

|

.. figure:: ../demonstrations/optimal_control/OptimalControl_distance.png
    :align: center
    :width: 100%
    :alt: Illustration of a mountain with a path drawn from the ground to the peak, with markers for a pulse unitary and a CNOT gate
    :target: javascript:void(0);

|

We can then maximize the fidelity :math:`F`, for example, using gradient-based
optimization algorithms like Adam [#KingmaBa14]_.
But how do we obtain the gradient of a function that requires us to run an ODE solver
to obtain its value? We are in luck! The implementation of pulse programming in PennyLane is
fully differentiable via backpropagation thanks to its backend based on the machine
learning library `JAX <https://jax.readthedocs.io/en/latest/>`__.
This enables us to optimize the gate sequences using efficiently computed gradients
(provided the target gate is not too large).

Before we climb mount fidelity for particular example gates, let's briefly talk about
the pulse shape that we will use.

Smooth rectangle pulses
-----------------------

Let's look at a building block that we will use a lot: smoothened rectangular pulses.
We start with a simple rectangular pulse

.. math::

    R_\infty(t, (\Omega, t_0, t_1)) = \Omega \Theta(t-t_0) \Theta(t_1-t)

where :math:`\Omega` is the amplitude, :math:`t_0` and :math:`t_1` are the start and end
times of the pulse, and :math:`\Theta(t)` is the
`Heaviside step function <https://en.wikipedia.org/wiki/Heaviside_step_function>`__
which is one for :math:`t\geq 0` and zero otherwise.
The trainable parameters of this pulse are the amplitude and the start/end times.

There are two main issues with :math:`R_\infty` for our purposes:

#. The Heaviside step function is not differentiable with respect
   to the times :math:`t_0` and :math:`t_1` in the conventional sense (but
   only if we were to consider distributions in addition to functions), and in
   particular we cannot differentiate the resulting :math:`U(\boldsymbol{p},T)`
   within the automatic differentiation framework provided by JAX.

#. The instantaneous change in the amplitude will not be realizable in practice.
   In reality, the pulses describe some electromagnetic control field that can only
   be changed at a bounded rate and in a smooth manner. :math:`R_\infty` is not
   only not smooth, it is not even continuous. So we should consider smooth
   pulses with a bounded rate of change instead.

We can solve both these issues by smoothening the rectangular pulse:
We simply replace the step functions above by a smooth variant, namely by sigmoid functions:

.. math::

    R_k(t, (\Omega, t_0, t_1)) &= \Omega S(t-t_0, k) S(t_1-t, k)\\
    S(t, k) &= (1+\exp(-k t))^{-1}.

We introduced an additional parameter, :math:`k`, that controls the steepness of the sigmoid
functions and can be adapted to the constraints posed by hardware on the maximal rate of change.
In contrast to :math:`R_\infty`, its sister :math:`R_k` is smooth in all three arguments
:math:`\Omega`, :math:`t_0` and :math:`t_1`, and training these three parameters with
automatic differentiation will not be a problem.

|

.. figure:: ../demonstrations/optimal_control/OptimalControl_Smoother_Rectangles.png
    :align: center
    :width: 100%
    :alt: Sketch of converting a rectangular pulse shape into a smoothened rectangular pulse shape
    :target: javascript:void(0);

|

Let's implement the smooth rectangle function using JAX's ``numpy``. We
directly implement the product of the two sigmoids in the function ``sigmoid_rectangle``:

.. math::

    R_k(t, (\Omega, t_0, t_1), k)=
    \Omega [1+\exp(-k (t-t_0))+\exp(-k (t_1-t))+\exp(-k(t_1-t_0))]^{-1}.

.. GENERATED FROM PYTHON SOURCE LINES 260-262

Let's look at a rectangular pulse and its smoothened sister, for a number of
different smoothness parameters:

.. GENERATED FROM PYTHON SOURCE LINES 281-353

We see that for very large :math:`k`, the smooth rectangle becomes practically
indistinguishable from the original rectangle function :math:`R_\infty`. This means
that we can consider the smooth :math:`R_k` a *generalization* of the pulse shape,
rather than a restriction.

In the examples below, we will use a pulse ansatz :math:`S_k` that sums multiple smooth rectangles
:math:`R_k` with the same value for :math:`k` but individual start/end times
:math:`t_{0/1}` and amplitudes :math:`\Omega`.
With this nicely trainable pulse shape in our hands, we now turn to the first gate
calibration task.

Pulse ansatz for CNOT calibration
---------------------------------

In this first example we will tune a two-qubit pulse to produce a standard CNOT gate.

We start by choosing a system Hamiltonian.
It contains the drift term :math:`H_d = Z_0 + Z_1`, i.e. a Pauli :math:`Z` operator
acting on each qubit, with a constant unit amplitude.
The parametrized part uses five generating terms: Pauli :math:`Z` acting on the
first qubit (:math:`Z_0`), all three Pauli operators acting on the second qubit
(:math:`X_1, Y_1, Z_1`) and a single interaction term :math:`Z_0X_1`, resembling an
abstract cross-resonance driving term. For all coefficient functions we choose
the same function, :math:`f_i=S_k\ \forall i` (see the section above), but with distinct
parameters. That is, our Hamiltonian is

.. math::

    H(\boldsymbol{p}, t) = \underset{H_d}{\underbrace{Z_0 + Z_1}}
    + S_k(\boldsymbol{p_1}, t) Z_0
    + S_k(\boldsymbol{p_2}, t) X_1
    + S_k(\boldsymbol{p_3}, t) Y_1
    + S_k(\boldsymbol{p_4}, t) Z_1
    + \underset{\text{interaction}}{\underbrace{S_k(\boldsymbol{p_5}, t) Z_0X_1}}

Due to this choice, the :math:`Z_0` term
commutes with all other terms, including the drift term, and can be considered a
correction of the drive term to obtain the correct action on the first qubit.
Although the interaction term was chosen to resemble a typical interaction in a
superconducting cross resonance drive, this Hamiltonian remains a toy model.
Realistic hardware Hamiltonians may impose additional constraints or provide
fewer controls, and we do not consider the unit systems of such real-world systems
here.

The idea behind using the sum of smooth rectangles function for the parametrization
is the following:
Many methods in quantum optimal control work with discretized pulse shapes that keep
the pulse envelope constant for short time bins. This approach leads to a large number
of parameters that need to be trained, and it requires us to manually enforce that the
values do not differ by too much between neighbouring time bins.
The smooth rectangles introduced above have a limited rate of change by design, and
the number of parameters is much smaller than in generic discretization approaches.
Each coefficient function :math:`S_k` sums :math:`P` smooth rectangles
:math:`R_k` with individual amplitudes and start and end times. Overall, this leads to
:math:`n=5\cdot 3\cdot P=15P` parameters in :math:`H`.
In this and the next example, we chose :math:`P` heuristically.

Before we define this Hamiltonian, we implement the sum over multiple
``sigmoid_rectangle`` functions, including two normalization steps.
First, we normalize the start and end times of the rectangles to the interval
:math:`[\epsilon, T-\epsilon]`, which makes sure that the pulse amplitudes are
close to zero at :math:`t=0` and :math:`t=T`. Without this step, we might be
tuning the pulses to be turned on (off) instantaneously at the beginning (end) of the
sequence, negating our effort on the pulse shape itself not to vary too quickly.
Second, we normalize the final output value to the interval
:math:`(-\Omega_\text{max}, \Omega_\text{max})`, which
allows us to bound the maximal amplitudes of the pulses to a realizable range while
maintaining differentiability.

For the normalization steps, we define a ``sigmoid`` and a ``normalize`` function.
The first is a straightforward implementation of :math:`R_k` whereas the second
uses the ``sigmoid`` function to normalize real numbers to the interval :math:`(-1, 1)`.

.. GENERATED FROM PYTHON SOURCE LINES 399-401

Let's look at this function for some example parameters, with the same steepness
parameter :math:`k=20` for all rectangles in the sum:

.. GENERATED FROM PYTHON SOURCE LINES 401-424

.. code-block:: default








    # Bind hyperparameters to the smooth_rectangles function


    # Set some arbitrary amplitudes and times



















.. GENERATED FROM PYTHON SOURCE LINES 425-445

Note that the rectangles are rather round for these generic parameters.
The optimized parameters in the training workflows below will lead to more
sharply defined pulses that resemble rectangles more closely. The amplitude normalization
step in ``smooth_rectangles`` enables us to produce them in a differentiable manner,
as was our goal with introducing :math:`R_k`.
Also note that the normalization of the final output value is not a simple clipping
step, but again a smooth function. As a consequence, the amplitudes ``1.9`` and ``-2.``
in the example above, which are not in the interval ``[-1, 1]``,
are not set to ``1`` and ``-1`` but take smaller absolute values.
Finally, also note that the start and end times of the smooth rectangles are being
normalized as well, in order to not end up too close to the boundaries of the
total time interval. While this makes the pulse times differ from the input times,
our pulse training will automatically consider this normalization step so that
it has no major consequences for us.

Using this function, we now may build the parametrized pulse Hamiltonian and the
fidelity function discussed above. We make use of just-in-time (JIT) compilation,
which will make the first execution of ``profit`` and ``grad`` slower, but speed
up the subsequent executions a lot. For optimization workflows of small-scale
functions, this almost always pays off.

.. GENERATED FROM PYTHON SOURCE LINES 445-484

.. code-block:: default







    # Hamiltonian terms of the drift and parametrized parts of H


    # Coefficients: 1 for drift Hamiltonian and smooth rectangles for parametrized part

    # Build H

    # Set tolerances for the ODE solver


    # Target unitary is CNOT. We get its matrix and note that we do not need the dagger
    # because CNOT is Hermitian.




























.. GENERATED FROM PYTHON SOURCE LINES 485-487

For the arbitrary parameters from above, of course we get a rather arbitrary unitary
time evolution, which does not match the CNOT at all:

.. GENERATED FROM PYTHON SOURCE LINES 497-501

Before we can start the optimization, we require initial parameters.
We set small alternating amplitudes and evenly distributed start and end times
for :math:`P=3` smoothened rectangles. This choice leads to
a total of :math:`15P=45` parameters in the pulse sequence.

.. GENERATED FROM PYTHON SOURCE LINES 501-508

.. code-block:: default



    # Initial parameters for the start and end times of the rectangles

    # All initial parameters: small alternating amplitudes and times









.. GENERATED FROM PYTHON SOURCE LINES 509-517

Now we are all set up to train the parameters of the pulse sequence to produce
our target gate, the CNOT. We will use the Adam optimizer [#KingmaBa14]_, implemented in the
`optax <https://optax.readthedocs.io/en/latest/>`__
library to our convenience. We keep track of the optimization via a list that contains
the parameters and fidelity values. Then we can plot the fidelity across the optimization.
As we will run a second optimization later on, we code up the optimizer run as a function.
This function will report on the optimization progress and duration, and it will plot
the trajectory of the profit function during the optimization.

.. GENERATED FROM PYTHON SOURCE LINES 552-564

As we can see, Adam steadily increases the fidelity, bringing the pulse program
closer and closer to the target unitary. On its way, the optimizer produces a mild
oscillating behaviour. The precision to which the optimization can produce the
target unitary depends on the expressivity of the pulses we use,
but also on the precision with which we run the ODE solver and the hyperparameters
of the optimizer.

Let's pick those parameters with the largest fidelity we observed during
the training and take a look at the pulses we found. We again prepare a function
that plots the pulse sequence, which we can reuse later on.
For the single-qubit terms, we encode their qubit in the color and the type of Pauli
operator in the line style of the plotted line.

.. GENERATED FROM PYTHON SOURCE LINES 608-638

We observe that a single rectangular pulse is sufficient for some of the
generating terms in the Hamiltonian whereas others end up at rather intricate
pulse shapes. We see that their shape is closer to
actual rectangles now, in particular for those with a saturated amplitude.

The final fidelity tells us that we achieved our goal of finding a pulse
sequence that implements a unitary close to a CNOT gate.
It could be optimized further, for example by running the optimization for more
training iterations, by tuning the optimizer further to avoid oscillations,
or by increasing the precision with which we run the ODE solver.
This likely would also allow to reduce the total duration of the pulse.

Pulse sequence for Toffoli
--------------------------

The second example we consider is the compilation of a Toffoli--or CCNOT--gate.
We reuse most of the workflow from above and only change the pulse Hamiltonian as
well as a few hyperparameters.

In particular, the Hamiltonian uses the drift term :math:`H_d=Z_0+Z_1+Z_2`
and the generators are all single-qubit Pauli operators on all three qubits, together
with the interaction generators :math:`Z_0X_1, Z_1X_2, Z_2X_0`. Again,
all parametrized terms use the coefficient function ``smooth_rectangles``.
We allow for a longer pulse duration of :math:`3\pi` and five smooth rectangles in
each pulse shape.

In summary, we use nine single-qubit generators and three two-qubit generators, with
five rectangles in each pulse shape and each rectangle being given by an amplitude and
a start and end time. The pulse sequence thus has :math:`(9+3)\cdot 5\cdot 3=180`
parameters.

.. GENERATED FROM PYTHON SOURCE LINES 638-681

.. code-block:: default



    # New pulse hyperparameters





    # Hamiltonian terms of the drift and parametrized parts of H




    # Coefficients: 1. for drift Hamiltonian and smooth rectangles for parametrized part

    # Build H

    # Set tolerances for the ODE solver


    # Target unitary is Toffoli. We get its matrix and note that we do not need the dagger
    # because Toffoli is Hermitian and unitary.




























.. GENERATED FROM PYTHON SOURCE LINES 682-687

We create initial parameters similar to the above but allow for a larger number
of :math:`1200` optimization steps and use a reduced learning rate (by absolute value)
in the optimization with Adam. Our ``run_adam`` function from above comes
in handy and also provides an overview of the optimization process in the
produced plot.

.. GENERATED FROM PYTHON SOURCE LINES 699-706

This looks promising: Adam maximized the fidelity successfully and we thus compiled
a pulse sequence that implements a Toffoli gate!
To inspect how close the compiled pulse sequence is to the Toffoli gate,
we can apply it to an exemplary quantum state, say :math:`|110\rangle`,
and investigate the returned probabilities. A perfect Toffoli gate would
flip the third qubit, returning a probability of one in the last entry
and zeros elsewhere.

.. GENERATED FROM PYTHON SOURCE LINES 725-732

We see that the returned probabilities are close to the expected vector. The
last entry is close to one, the others are almost zero.
However, there are more possible inputs to the gate, and we hardly want to
stare at eight probability vectors to understand the quality of the compiled
pulse sequence. Instead, let's plot the transition amplitudes with which our
compiled pulse sequence maps computational basis vectors to each other.
We include the complex phase of the amplitudes in the color of the bars.

.. GENERATED FROM PYTHON SOURCE LINES 732-765

.. code-block:: default














    # Barplot with x, y positions, bottom, width, depth and height values for bars

    # Specify a few visual attributes of the axes object









    # Add axes for the colorbar



    # Plot colorbar










.. GENERATED FROM PYTHON SOURCE LINES 766-773

The transition amplitudes are as expected, except for very small deviations.
All computational basis states are mapped to themselves, but the last two are
swapped. The color of the entries close to one does not correspond to a phase
of zero. However, the fact that they have the same color tells us that this
deviation is a global phase, so that the pulse sequence is equivalent to
the Toffoli gate.
Let's also look at the pulse sequence itself:

.. GENERATED FROM PYTHON SOURCE LINES 777-854

As we can see, the optimized smooth rectangles do not fill out the time at maximal
amplitudes. This means that we probably can find shorter pulse sequences with
larger amplitudes that produce a Toffoli with the
same fidelity. If you are interested, take a shot at it and try to
optimize the sequence with respect to the number of generators and pulse duration!

Conclusion
----------

In this tutorial we calibrated a two-qubit and a three-qubit pulse sequence
to obtain a CNOT and a Toffoli gate, respectively. For this, we used smooth
rectangular pulse shapes together with toy pulse Hamiltonians, and obtained
very good approximations to the target gates.
Thanks to JAX, just-in-time (JIT) compiling and the PennyLane ``pulse``
module, training the pulse sequences was simple to implement and fast to run.

There are many different techniques in quantum optimal control that can be
used to calibrate pulse sequences, some of which include gradient-based
training. A widely-used technique called GRAPE [#KhanejaReiss05]_
makes use of discretized pulses, which leads to a large number of free parameters
to be optimized with gradient ascent.
The technique shown here reduces the parameter count significantly
and provides smooth, bounded shapes by definition.

Yet another method that does *not* use gradient-based optimization is
the chopped random-basis quantum optimization (CRAB) algorithm [#DoriaCalarco11]_.
It uses a different parametrization altogether, exploiting randomized basis functions
for the pulse envelopes.

While setting up the application examples, we accommodated for
some requirements of realistic hardware, like smooth pulse shapes with bounded
maximal amplitudes and bounded rates of change, and we tried to use only few
interaction terms between qubits. However, it is important to note
that the shown optimization remains a toy model for calibration of
quantum hardware. We did not take into account the interaction terms
or pulse shapes available on realistic devices and their control electronics.
We also did not consider a unit system tied to real devices, and we
ignored noise, which plays a very important role in today's quantum devices
and in quantum optimal control.
We leave the extension to real-world pulse Hamiltonians and noisy systems
to a future tutorial--or maybe your work?

References
-------------

.. [#CanevaMurphy09]

    T. Caneva, M. Murphy, T. Calarco, R. Fazio, S. Montangero, V. Giovannetti and G. Santoro
    "Optimal Control at the Quantum Speed Limit"
    `Phys. Rev. Lett. 103, 240501 <https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.103.240501>`__,
    `arxiv:0902.4193 <https://arxiv.org/abs/0902.4193>__, 2009

.. [#KingmaBa14]

    D. Kingma and J. Ba
    "Adam: A method for Stochastic Optimization"
    `arxiv:1412.6980 <https://arxiv.org/abs/1412.6980>`__, 2014

.. [#KhanejaReiss05]

    N. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbrüggen, S.J. Glaser
    "Optimal Control of Coupled Spin Dynamics:
    Design of NMR Pulse Sequences by Gradient Ascent Algorithms"
    `J. Magn. Reson. 172, 296-305 <https://www.ch.nat.tum.de/fileadmin/w00bzu/ocnmr/pdf/94_GRAPE_JMR_05_.pdf>`__,
    2005

.. [#DoriaCalarco11]

    P. Doria, T. Calarco and S. Montangero
    "Optimal Control Technique for Many-Body Quantum Dynamics"
    `Phys. Rev. Lett. 106, 190501 <https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.106.190501>`__,
    `arxiv:1003.3750 <https://arxiv.org/abs/1003.3750>`__, 2011


About the author
----------------
.. include:: ../_static/authors/david_wierichs.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.001 seconds)


.. _sphx_glr_download_demos_tutorial_optimal_control.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: tutorial_optimal_control.py <tutorial_optimal_control.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: tutorial_optimal_control.ipynb <tutorial_optimal_control.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_

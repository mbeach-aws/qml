
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "demos/vqe_parallel.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_demos_vqe_parallel.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_demos_vqe_parallel.py:


VQE with parallel QPUs with Rigetti
========================================

.. meta::
    :property="og:description": Using parallel QPUs to
        speed up the calculation of the potential energy surface of molecular Hamiltonian.
    :property="og:image": https://pennylane.ai/qml/_images/vqe_diagram.png

.. related::

   tutorial_vqe A brief overview of VQE

*Author: Tom Bromley — Posted: 14 February 2020. Last updated: 9 November 2022.*

This tutorial showcases how using asynchronously-evaluated parallel QPUs can speed up the
calculation of the potential energy surface of molecular hydrogen (:math:`H_2`).

Using a VQE setup, we task two devices from the
`PennyLane-Rigetti <https://docs.pennylane.ai/projects/rigetti/en/latest/>`__ plugin with evaluating

separate terms in the qubit Hamiltonian of :math:`H_2`. As these devices are allowed to operate
asynchronously, i.e., at the same time and without having to wait for each other,
the calculation can be performed in roughly half the time.

We begin by importing the prerequisite libraries:

.. GENERATED FROM PYTHON SOURCE LINES 39-65

This tutorial requires the ``pennylane-rigetti`` and ``dask``
packages, which are installed separately using:

.. code-block:: bash

   pip install pennylane-rigetti
   pip install "dask[delayed]"

Finding the qubit Hamiltonians of :math:`H_{2}`
-----------------------------------------------

The objective of this tutorial is to evaluate the potential energy surface of molecular
hydrogen. This is achieved by finding the ground state energy of :math:`H_{2}` as we increase
the bond length between the hydrogen atoms.

Each inter-atomic distance results in a different qubit Hamiltonian. To find the corresponding
Hamiltonian, we use the :func:`~.pennylane.qchem.molecular_hamiltonian` function of the
:mod:`~.pennylane.qchem` package. Further details on the mapping from the electronic
Hamiltonian of a molecule to a qubit Hamiltonian can be found in the
:doc:`tutorial_quantum_chemistry` and :doc:`tutorial_vqe`
tutorials.

We begin by creating a dictionary containing a selection of bond lengths and corresponding data
files saved in `XYZ <https://en.wikipedia.org/wiki/XYZ_file_format>`__ format. These files
follow a standard format for specifying the geometry of a molecule and can be downloaded as a
Zip from :download:`here <../demonstrations/vqe_parallel/vqe_parallel.zip>`.

.. GENERATED FROM PYTHON SOURCE LINES 81-85

The next step is to create the qubit Hamiltonians for each value of the inter-atomic distance.
We do this by first reading the molecular geometry from the external file using the
:func:`~.pennylane.qchem.read_structure` function and passing the atomic symbols
and coordinates to :func:`~.pennylane.qchem.molecular_hamiltonian`.

.. GENERATED FROM PYTHON SOURCE LINES 95-97

Each Hamiltonian can be written as a linear combination of fifteen tensor products of Pauli
matrices. Let's take a look more closely at one of the Hamiltonians:

.. GENERATED FROM PYTHON SOURCE LINES 105-128

.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

   Number of terms: 15

   Measurement Identity on wires <Wires = [0]>
   Measurement PauliZ on wires <Wires = [0]>
   Measurement PauliZ on wires <Wires = [1]>
   Measurement ['PauliZ', 'PauliZ'] on wires <Wires = [0, 1]>
   Measurement ['PauliY', 'PauliX', 'PauliX', 'PauliY'] on wires <Wires = [0, 1, 2, 3]>
   Measurement ['PauliY', 'PauliY', 'PauliX', 'PauliX'] on wires <Wires = [0, 1, 2, 3]>
   Measurement ['PauliX', 'PauliX', 'PauliY', 'PauliY'] on wires <Wires = [0, 1, 2, 3]>
   Measurement ['PauliX', 'PauliY', 'PauliY', 'PauliX'] on wires <Wires = [0, 1, 2, 3]>
   Measurement PauliZ on wires <Wires = [2]>
   Measurement ['PauliZ', 'PauliZ'] on wires <Wires = [0, 2]>
   Measurement PauliZ on wires <Wires = [3]>
   Measurement ['PauliZ', 'PauliZ'] on wires <Wires = [0, 3]>
   Measurement ['PauliZ', 'PauliZ'] on wires <Wires = [1, 2]>
   Measurement ['PauliZ', 'PauliZ'] on wires <Wires = [1, 3]>
   Measurement ['PauliZ', 'PauliZ'] on wires <Wires = [2, 3]>

.. GENERATED FROM PYTHON SOURCE LINES 130-156

Defining the energy function
----------------------------

The fifteen Pauli terms comprising each Hamiltonian can conventionally be evaluated in a
sequential manner: we evaluate one expectation value at a time before moving on to the next.
However, this task is highly suited to parallelization. With access to multiple QPUs,
we can split up evaluating the terms between the QPUs and gain an increase in processing speed.


.. note::
   Some of the Pauli terms commute, and so they can be evaluated in practice with fewer than
   fifteen quantum circuit runs. Nevertheless, these quantum circuit runs can still be
   parallelized to multiple QPUs.

Let's suppose we have access to two quantum devices. In this tutorial we consider two
simulators from Rigetti: ``4q-qvm`` and ``9q-square-qvm``, but we could also run on hardware
devices from Rigetti or other providers.

We can evaluate the expectation value of each Hamiltonian with eight terms run on
one device and seven terms run on the other, as summarized by the diagram below:

.. figure:: /demonstrations/vqe_parallel/vqe_diagram.png
   :width: 65%
   :align: center

To do this, start by instantiating a device for each term:

.. GENERATED FROM PYTHON SOURCE LINES 162-186

.. note::

    For the purposes of this demonstration, we are simulating the QPUs using the
    ``rigetti.qvm`` simulator. To run this demonstration on hardware, simply
    swap ``rigetti.qvm`` for ``rigetti.qpu`` and specify the hardware device to run on.

    Please refer to the `Rigetti website <https://rigetti.com/>`__ for an up-to-date
    list on available QPUs.

.. warning::
   Rigetti's QVM and Quil Compiler services must be running for this tutorial to execute. They
   can be installed by consulting the `Rigetti documentation
   <http://docs.rigetti.com/qcs/>`__ or, for users with Docker, by running:

   .. code-block:: bash

       docker run -d -p 5555:5555 rigetti/quilc -R -p 5555
       docker run -d -p 5000:5000 rigetti/qvm -S -p 5000

We must also define a circuit to prepare the ground state, which is a superposition of the
Hartree-Fock (:math:`|1100\rangle`) and doubly-excited (:math:`|0011\rangle`) configurations.
The simple circuit below is able to prepare states of the form :math:`\alpha |1100\rangle +
\beta |0011\rangle` and hence encode the ground state wave function of the hydrogen molecule. The
circuit has a single free parameter, which controls a Y-rotation on the third qubit.

.. GENERATED FROM PYTHON SOURCE LINES 198-204

The ground state for each inter-atomic distance is characterized by a different Y-rotation angle.
The values of these Y-rotations can be found by minimizing the ground state energy as outlined in
:doc:`tutorial_vqe`. In this tutorial, we load pre-optimized rotations and focus on
comparing the speed of evaluating the potential energy surface with sequential and parallel
evaluation. These parameters can be downloaded by clicking :download:`here
<../demonstrations/vqe_parallel/RY_params.npy>`.

.. GENERATED FROM PYTHON SOURCE LINES 208-212

Calculating the potential energy surface
----------------------------------------
The most vanilla execution of these 10 energy surfaces is using the standard PennyLane functionalities by executing the QNodes.
Internally, this creates a measurement for each term in the Hamiltonian that are then sequentially computed.

.. GENERATED FROM PYTHON SOURCE LINES 226-229

We can parallelize the individual evaluations using ``dask`` in the following way: We take the 15 terms of the Hamiltonian and
distribute them to the 15 devices in ``devs``. This evaluation is delayed using ``dask.delayed`` and later computed
in parallel using ``dask.compute``, which asynchronously executes the delayed objects in ``results``.

.. GENERATED FROM PYTHON SOURCE LINES 242-246

We can now compute all 10 samples from the energy surface sequentially, where each execution is making use of 
parallel device execution. Curiously, in this example the overhead from doing so outweighs the speed-up
and the execution is slower than standard execution using ``qml.expval``. For different circuits and
different Hamiltonians, however, parallelization may provide significant speed-ups.

.. GENERATED FROM PYTHON SOURCE LINES 261-265

We can improve this procedure further by optimizing the measurement. Currently, we are measuring each term of the Hamiltonian
in a separate measurement. This is not necessary as there are sub-groups of commuting terms in the Hamiltonian that can be measured
simultaneously. We can utilize the grouping function :func:`~.pennylane.pauli.group_observables` to generate few measurements that
are executed in parallel:

.. GENERATED FROM PYTHON SOURCE LINES 294-338

.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

   Evaluating the potential energy surface sequentially
   1 / 10: Sequential execution; Running for inter-atomic distance 0.3 Å
   2 / 10: Sequential execution; Running for inter-atomic distance 0.5 Å
   3 / 10: Sequential execution; Running for inter-atomic distance 0.7 Å
   4 / 10: Sequential execution; Running for inter-atomic distance 0.9 Å
   5 / 10: Sequential execution; Running for inter-atomic distance 1.1 Å
   6 / 10: Sequential execution; Running for inter-atomic distance 1.3 Å
   7 / 10: Sequential execution; Running for inter-atomic distance 1.5 Å
   8 / 10: Sequential execution; Running for inter-atomic distance 1.7 Å
   9 / 10: Sequential execution; Running for inter-atomic distance 1.9 Å
   10 / 10: Sequential execution; Running for inter-atomic distance 2.1 Å
   Evaluation time: 39.33 s

   Evaluating the potential energy surface in parallel
   1 / 10: Parallel execution; Running for inter-atomic distance 0.3 Å
   2 / 10: Parallel execution; Running for inter-atomic distance 0.5 Å
   3 / 10: Parallel execution; Running for inter-atomic distance 0.7 Å
   4 / 10: Parallel execution; Running for inter-atomic distance 0.9 Å
   5 / 10: Parallel execution; Running for inter-atomic distance 1.1 Å
   6 / 10: Parallel execution; Running for inter-atomic distance 1.3 Å
   7 / 10: Parallel execution; Running for inter-atomic distance 1.5 Å
   8 / 10: Parallel execution; Running for inter-atomic distance 1.7 Å
   9 / 10: Parallel execution; Running for inter-atomic distance 1.9 Å
   10 / 10: Parallel execution; Running for inter-atomic distance 2.1 Å
   Evaluation time: 73.42 s

   Evaluating the potential energy surface in parallel with measurement optimization
   1 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 0.3 Å
   2 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 0.5 Å
   3 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 0.7 Å
   4 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 0.9 Å
   5 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 1.1 Å
   6 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 1.3 Å
   7 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 1.5 Å
   8 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 1.7 Å
   9 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 1.9 Å
   10 / 10: Parallel execution and measurement optimization; Running for inter-atomic distance 2.1 Å
   Evaluation time: 26.51 s

.. GENERATED FROM PYTHON SOURCE LINES 341-342

We have seen how Hamiltonian measurements can be parallelized and optimized at the same time.

.. GENERATED FROM PYTHON SOURCE LINES 346-353

.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

   Speed up: 1.48

.. GENERATED FROM PYTHON SOURCE LINES 355-357

To conclude the tutorial, let's plot the calculated
potential energy surfaces:

.. GENERATED FROM PYTHON SOURCE LINES 370-374

.. figure:: /demonstrations/vqe_parallel/vqe_parallel_001.png
   :width: 80%
   :align: center


.. GENERATED FROM PYTHON SOURCE LINES 376-379

These surfaces overlap, with any variation due to the limited number of shots used to evaluate the
expectation values in the ``rigetti.qvm`` device (we are using the default value of
``shots=1024``).

.. GENERATED FROM PYTHON SOURCE LINES 381-383

About the author
----------------
.. include:: ../_static/authors/thomas_bromley.txt


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  0.000 seconds)


.. _sphx_glr_download_demos_vqe_parallel.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: vqe_parallel.py <vqe_parallel.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: vqe_parallel.ipynb <vqe_parallel.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
